// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace RunN64.External.Rsp
{
    public enum OSTask_type : uint
    {
        M_GFXTASK = 1,
        M_AUDTASK = 2,
        M_VIDTASK = 3,
        M_NJPEGTASK = 4,
        M_NULTASK = 5,
        M_HVQTASK = 6,
        M_HVQMTASK = 7,
        NUM_KNOWN_TASK_TYPES = 8
    }

    public unsafe partial class module
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "_Z11update_confPKc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UpdateConf([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string source);

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "_Z17export_data_cachev", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ExportDataCache();

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "_Z24export_instruction_cachev", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ExportInstructionCache();

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "_Z16export_SP_memoryv", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ExportSP_memory();
        }

        public static void UpdateConf(string source)
        {
            __Internal.UpdateConf(source);
        }

        public static void ExportDataCache()
        {
            __Internal.ExportDataCache();
        }

        public static void ExportInstructionCache()
        {
            __Internal.ExportInstructionCache();
        }

        public static void ExportSP_memory()
        {
            __Internal.ExportSP_memory();
        }

        public static global::RunN64.External.Rsp.PFunc GBI_phase
        {
            get
            {
                var __ptr = (__IntPtr*)global::RunN64.External.Rsp.__Symbols.rsp_so._GBI_phase;
                var __ptr0 = *__ptr;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.Rsp.PFunc) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.Rsp.PFunc));
            }

            set
            {
                var __ptr = (__IntPtr*)global::RunN64.External.Rsp.__Symbols.rsp_so._GBI_phase;
                *__ptr = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void PFunc();

    public unsafe partial struct Word16
    {
        [StructLayout(LayoutKind.Explicit, Size = 2)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal fixed byte B[2];

            [FieldOffset(0)]
            internal fixed sbyte SB[2];

            [FieldOffset(0)]
            internal short W;

            [FieldOffset(0)]
            internal ushort UW;

            [FieldOffset(0)]
            internal short SW;

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "_ZN7word_16C2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
        }

        private Word16.__Internal __instance;
        internal Word16.__Internal __Instance { get { return __instance; } }

        internal static Word16 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new Word16(native.ToPointer(), skipVTables);
        }

        internal static Word16 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Word16(native, skipVTables);
        }

        private Word16(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private Word16(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::RunN64.External.Rsp.Word16.__Internal*) native;
        }

        public Word16(global::RunN64.External.Rsp.Word16 __0)
            : this()
        {
            var ____arg0 = __0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        public byte[] B
        {
            get
            {
                fixed (byte* __arrPtr = __instance.B)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<byte>(__arrPtr, 2);
                }
            }

            set
            {
                fixed (byte* __arrPtr = __instance.B)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 2; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }

        public sbyte[] SB
        {
            get
            {
                fixed (sbyte* __arrPtr = __instance.SB)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(__arrPtr, 2);
                }
            }

            set
            {
                fixed (sbyte* __arrPtr = __instance.SB)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 2; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }

        public short W
        {
            get
            {
                return __instance.W;
            }

            set
            {
                __instance.W = value;
            }
        }

        public ushort UW
        {
            get
            {
                return __instance.UW;
            }

            set
            {
                __instance.UW = value;
            }
        }

        public short SW
        {
            get
            {
                return __instance.SW;
            }

            set
            {
                __instance.SW = value;
            }
        }
    }

    public unsafe partial struct Word32
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal fixed byte B[4];

            [FieldOffset(0)]
            internal fixed sbyte SB[4];

            [FieldOffset(0)]
            internal fixed short H[2];

            [FieldOffset(0)]
            internal fixed ushort UH[2];

            [FieldOffset(0)]
            internal fixed short SH[2];

            [FieldOffset(0)]
            internal int W;

            [FieldOffset(0)]
            internal uint UW;

            [FieldOffset(0)]
            internal int SW;

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "_ZN7word_32C2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
        }

        private Word32.__Internal __instance;
        internal Word32.__Internal __Instance { get { return __instance; } }

        internal static Word32 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new Word32(native.ToPointer(), skipVTables);
        }

        internal static Word32 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Word32(native, skipVTables);
        }

        private Word32(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private Word32(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::RunN64.External.Rsp.Word32.__Internal*) native;
        }

        public Word32(global::RunN64.External.Rsp.Word32 __0)
            : this()
        {
            var ____arg0 = __0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        public byte[] B
        {
            get
            {
                fixed (byte* __arrPtr = __instance.B)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<byte>(__arrPtr, 4);
                }
            }

            set
            {
                fixed (byte* __arrPtr = __instance.B)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 4; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }

        public sbyte[] SB
        {
            get
            {
                fixed (sbyte* __arrPtr = __instance.SB)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(__arrPtr, 4);
                }
            }

            set
            {
                fixed (sbyte* __arrPtr = __instance.SB)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 4; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }

        public short[] H
        {
            get
            {
                fixed (short* __arrPtr = __instance.H)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<short>(__arrPtr, 2);
                }
            }

            set
            {
                fixed (short* __arrPtr = __instance.H)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 2; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }

        public ushort[] UH
        {
            get
            {
                fixed (ushort* __arrPtr = __instance.UH)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<ushort>(__arrPtr, 2);
                }
            }

            set
            {
                fixed (ushort* __arrPtr = __instance.UH)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 2; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }

        public short[] SH
        {
            get
            {
                fixed (short* __arrPtr = __instance.SH)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<short>(__arrPtr, 2);
                }
            }

            set
            {
                fixed (short* __arrPtr = __instance.SH)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 2; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }

        public int W
        {
            get
            {
                return __instance.W;
            }

            set
            {
                __instance.W = value;
            }
        }

        public uint UW
        {
            get
            {
                return __instance.UW;
            }

            set
            {
                __instance.UW = value;
            }
        }

        public int SW
        {
            get
            {
                return __instance.SW;
            }

            set
            {
                __instance.SW = value;
            }
        }
    }

    public unsafe partial struct Word64
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal fixed byte B[8];

            [FieldOffset(0)]
            internal fixed sbyte SB[8];

            [FieldOffset(0)]
            internal fixed short Q[4];

            [FieldOffset(0)]
            internal fixed ushort UQ[4];

            [FieldOffset(0)]
            internal fixed short SQ[4];

            [FieldOffset(0)]
            internal fixed int H[2];

            [FieldOffset(0)]
            internal fixed uint UH[2];

            [FieldOffset(0)]
            internal fixed int SH[2];

            [FieldOffset(0)]
            internal long W;

            [FieldOffset(0)]
            internal ulong UW;

            [FieldOffset(0)]
            internal long SW;

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "_ZN7word_64C2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
        }

        private Word64.__Internal __instance;
        internal Word64.__Internal __Instance { get { return __instance; } }

        internal static Word64 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new Word64(native.ToPointer(), skipVTables);
        }

        internal static Word64 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Word64(native, skipVTables);
        }

        private Word64(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private Word64(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::RunN64.External.Rsp.Word64.__Internal*) native;
        }

        public Word64(global::RunN64.External.Rsp.Word64 __0)
            : this()
        {
            var ____arg0 = __0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        public byte[] B
        {
            get
            {
                fixed (byte* __arrPtr = __instance.B)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<byte>(__arrPtr, 8);
                }
            }

            set
            {
                fixed (byte* __arrPtr = __instance.B)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 8; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }

        public sbyte[] SB
        {
            get
            {
                fixed (sbyte* __arrPtr = __instance.SB)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(__arrPtr, 8);
                }
            }

            set
            {
                fixed (sbyte* __arrPtr = __instance.SB)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 8; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }

        public short[] Q
        {
            get
            {
                fixed (short* __arrPtr = __instance.Q)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<short>(__arrPtr, 4);
                }
            }

            set
            {
                fixed (short* __arrPtr = __instance.Q)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 4; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }

        public ushort[] UQ
        {
            get
            {
                fixed (ushort* __arrPtr = __instance.UQ)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<ushort>(__arrPtr, 4);
                }
            }

            set
            {
                fixed (ushort* __arrPtr = __instance.UQ)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 4; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }

        public short[] SQ
        {
            get
            {
                fixed (short* __arrPtr = __instance.SQ)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<short>(__arrPtr, 4);
                }
            }

            set
            {
                fixed (short* __arrPtr = __instance.SQ)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 4; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }

        public int[] H
        {
            get
            {
                fixed (int* __arrPtr = __instance.H)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<int>(__arrPtr, 2);
                }
            }

            set
            {
                fixed (int* __arrPtr = __instance.H)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 2; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }

        public uint[] UH
        {
            get
            {
                fixed (uint* __arrPtr = __instance.UH)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<uint>(__arrPtr, 2);
                }
            }

            set
            {
                fixed (uint* __arrPtr = __instance.UH)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 2; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }

        public int[] SH
        {
            get
            {
                fixed (int* __arrPtr = __instance.SH)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<int>(__arrPtr, 2);
                }
            }

            set
            {
                fixed (int* __arrPtr = __instance.SH)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 2; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }

        public long W
        {
            get
            {
                return __instance.W;
            }

            set
            {
                __instance.W = value;
            }
        }

        public ulong UW
        {
            get
            {
                return __instance.UW;
            }

            set
            {
                __instance.UW = value;
            }
        }

        public long SW
        {
            get
            {
                return __instance.SW;
            }

            set
            {
                __instance.SW = value;
            }
        }
    }

    public unsafe partial class MIPS_typeR : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint opcode;

            [FieldOffset(0)]
            internal uint rs;

            [FieldOffset(1)]
            internal uint rt;

            [FieldOffset(2)]
            internal uint rd;

            [FieldOffset(2)]
            internal uint sa;

            [FieldOffset(3)]
            internal uint function;

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "_ZN11MIPS_type_RC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.Rsp.MIPS_typeR> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.Rsp.MIPS_typeR>();

        protected bool __ownsNativeInstance;

        internal static MIPS_typeR __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new MIPS_typeR(native.ToPointer(), skipVTables);
        }

        internal static MIPS_typeR __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (MIPS_typeR)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static MIPS_typeR __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new MIPS_typeR(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MIPS_typeR(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MIPS_typeR(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public MIPS_typeR()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.Rsp.MIPS_typeR.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MIPS_typeR(global::RunN64.External.Rsp.MIPS_typeR __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.Rsp.MIPS_typeR.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::RunN64.External.Rsp.MIPS_typeR.__Internal*) __Instance) = *((global::RunN64.External.Rsp.MIPS_typeR.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Opcode
        {
            get
            {
                return ((__Internal*)__Instance)->opcode;
            }

            set
            {
                ((__Internal*)__Instance)->opcode = value;
            }
        }

        public uint Rs
        {
            get
            {
                return ((__Internal*)__Instance)->rs;
            }

            set
            {
                ((__Internal*)__Instance)->rs = value;
            }
        }

        public uint Rt
        {
            get
            {
                return ((__Internal*)__Instance)->rt;
            }

            set
            {
                ((__Internal*)__Instance)->rt = value;
            }
        }

        public uint Rd
        {
            get
            {
                return ((__Internal*)__Instance)->rd;
            }

            set
            {
                ((__Internal*)__Instance)->rd = value;
            }
        }

        public uint Sa
        {
            get
            {
                return ((__Internal*)__Instance)->sa;
            }

            set
            {
                ((__Internal*)__Instance)->sa = value;
            }
        }

        public uint Function
        {
            get
            {
                return ((__Internal*)__Instance)->function;
            }

            set
            {
                ((__Internal*)__Instance)->function = value;
            }
        }
    }

    public unsafe partial class MIPS_typeI : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint opcode;

            [FieldOffset(0)]
            internal uint rs;

            [FieldOffset(1)]
            internal uint rt;

            [FieldOffset(2)]
            internal uint immediate;

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "_ZN11MIPS_type_IC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.Rsp.MIPS_typeI> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.Rsp.MIPS_typeI>();

        protected bool __ownsNativeInstance;

        internal static MIPS_typeI __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new MIPS_typeI(native.ToPointer(), skipVTables);
        }

        internal static MIPS_typeI __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (MIPS_typeI)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static MIPS_typeI __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new MIPS_typeI(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MIPS_typeI(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MIPS_typeI(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public MIPS_typeI()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.Rsp.MIPS_typeI.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MIPS_typeI(global::RunN64.External.Rsp.MIPS_typeI __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.Rsp.MIPS_typeI.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::RunN64.External.Rsp.MIPS_typeI.__Internal*) __Instance) = *((global::RunN64.External.Rsp.MIPS_typeI.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Opcode
        {
            get
            {
                return ((__Internal*)__Instance)->opcode;
            }

            set
            {
                ((__Internal*)__Instance)->opcode = value;
            }
        }

        public uint Rs
        {
            get
            {
                return ((__Internal*)__Instance)->rs;
            }

            set
            {
                ((__Internal*)__Instance)->rs = value;
            }
        }

        public uint Rt
        {
            get
            {
                return ((__Internal*)__Instance)->rt;
            }

            set
            {
                ((__Internal*)__Instance)->rt = value;
            }
        }

        public uint Immediate
        {
            get
            {
                return ((__Internal*)__Instance)->immediate;
            }

            set
            {
                ((__Internal*)__Instance)->immediate = value;
            }
        }
    }

    public unsafe partial class MIPS_typeJ : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 4)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            internal uint opcode;

            [FieldOffset(0)]
            internal uint target;

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "_ZN11MIPS_type_JC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.Rsp.MIPS_typeJ> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.Rsp.MIPS_typeJ>();

        protected bool __ownsNativeInstance;

        internal static MIPS_typeJ __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new MIPS_typeJ(native.ToPointer(), skipVTables);
        }

        internal static MIPS_typeJ __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (MIPS_typeJ)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static MIPS_typeJ __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new MIPS_typeJ(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MIPS_typeJ(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MIPS_typeJ(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public MIPS_typeJ()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.Rsp.MIPS_typeJ.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MIPS_typeJ(global::RunN64.External.Rsp.MIPS_typeJ __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.Rsp.MIPS_typeJ.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::RunN64.External.Rsp.MIPS_typeJ.__Internal*) __Instance) = *((global::RunN64.External.Rsp.MIPS_typeJ.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Opcode
        {
            get
            {
                return ((__Internal*)__Instance)->opcode;
            }

            set
            {
                ((__Internal*)__Instance)->opcode = value;
            }
        }

        public uint Target
        {
            get
            {
                return ((__Internal*)__Instance)->target;
            }

            set
            {
                ((__Internal*)__Instance)->target = value;
            }
        }
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void InstDebugFunc(uint pc, uint inst);

    public unsafe partial class WinapiRect : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal int left;
            internal int top;
            internal int right;
            internal int bottom;

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "_ZN11winapi_rectC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.Rsp.WinapiRect> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.Rsp.WinapiRect>();

        protected bool __ownsNativeInstance;

        internal static WinapiRect __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new WinapiRect(native.ToPointer(), skipVTables);
        }

        internal static WinapiRect __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (WinapiRect)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static WinapiRect __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new WinapiRect(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private WinapiRect(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected WinapiRect(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public WinapiRect()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.Rsp.WinapiRect.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public WinapiRect(global::RunN64.External.Rsp.WinapiRect __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.Rsp.WinapiRect.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::RunN64.External.Rsp.WinapiRect.__Internal*) __Instance) = *((global::RunN64.External.Rsp.WinapiRect.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Left
        {
            get
            {
                return ((__Internal*)__Instance)->left;
            }

            set
            {
                ((__Internal*)__Instance)->left = value;
            }
        }

        public int Top
        {
            get
            {
                return ((__Internal*)__Instance)->top;
            }

            set
            {
                ((__Internal*)__Instance)->top = value;
            }
        }

        public int Right
        {
            get
            {
                return ((__Internal*)__Instance)->right;
            }

            set
            {
                ((__Internal*)__Instance)->right = value;
            }
        }

        public int Bottom
        {
            get
            {
                return ((__Internal*)__Instance)->bottom;
            }

            set
            {
                ((__Internal*)__Instance)->bottom = value;
            }
        }
    }

    public unsafe partial class WinapiPaintstruct : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 72)]
        public partial struct __Internal
        {
            internal __IntPtr hdc;
            internal int fErase;
            internal global::RunN64.External.Rsp.WinapiRect.__Internal rcPaint;
            internal int fRestore;
            internal int fIncUpdate;
            internal fixed byte rgbReserved[32];

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "_ZN18winapi_paintstructC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.Rsp.WinapiPaintstruct> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.Rsp.WinapiPaintstruct>();

        protected bool __ownsNativeInstance;

        internal static WinapiPaintstruct __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new WinapiPaintstruct(native.ToPointer(), skipVTables);
        }

        internal static WinapiPaintstruct __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (WinapiPaintstruct)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static WinapiPaintstruct __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new WinapiPaintstruct(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private WinapiPaintstruct(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected WinapiPaintstruct(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public WinapiPaintstruct()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.Rsp.WinapiPaintstruct.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public WinapiPaintstruct(global::RunN64.External.Rsp.WinapiPaintstruct __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.Rsp.WinapiPaintstruct.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::RunN64.External.Rsp.WinapiPaintstruct.__Internal*) __Instance) = *((global::RunN64.External.Rsp.WinapiPaintstruct.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr Hdc
        {
            get
            {
                return ((__Internal*)__Instance)->hdc;
            }

            set
            {
                ((__Internal*)__Instance)->hdc = (__IntPtr) value;
            }
        }

        public int FErase
        {
            get
            {
                return ((__Internal*)__Instance)->fErase;
            }

            set
            {
                ((__Internal*)__Instance)->fErase = value;
            }
        }

        public global::RunN64.External.Rsp.WinapiRect RcPaint
        {
            get
            {
                return global::RunN64.External.Rsp.WinapiRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->rcPaint));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->rcPaint = *(global::RunN64.External.Rsp.WinapiRect.__Internal*) value.__Instance;
            }
        }

        public int FRestore
        {
            get
            {
                return ((__Internal*)__Instance)->fRestore;
            }

            set
            {
                ((__Internal*)__Instance)->fRestore = value;
            }
        }

        public int FIncUpdate
        {
            get
            {
                return ((__Internal*)__Instance)->fIncUpdate;
            }

            set
            {
                ((__Internal*)__Instance)->fIncUpdate = value;
            }
        }

        public byte[] RgbReserved
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->rgbReserved, 32);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 32; i++)
                        ((__Internal*)__Instance)->rgbReserved[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class PLUGIN_INFO : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 112)]
        public partial struct __Internal
        {
            internal ushort Version;
            internal ushort Type;
            internal fixed sbyte Name[100];
            internal int NormalMemory;
            internal int MemoryBswaped;

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "_ZN11PLUGIN_INFOC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.Rsp.PLUGIN_INFO> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.Rsp.PLUGIN_INFO>();

        protected bool __ownsNativeInstance;

        internal static PLUGIN_INFO __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new PLUGIN_INFO(native.ToPointer(), skipVTables);
        }

        internal static PLUGIN_INFO __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (PLUGIN_INFO)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static PLUGIN_INFO __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PLUGIN_INFO(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PLUGIN_INFO(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PLUGIN_INFO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PLUGIN_INFO()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.Rsp.PLUGIN_INFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public PLUGIN_INFO(global::RunN64.External.Rsp.PLUGIN_INFO __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.Rsp.PLUGIN_INFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::RunN64.External.Rsp.PLUGIN_INFO.__Internal*) __Instance) = *((global::RunN64.External.Rsp.PLUGIN_INFO.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort Version
        {
            get
            {
                return ((__Internal*)__Instance)->Version;
            }

            set
            {
                ((__Internal*)__Instance)->Version = value;
            }
        }

        public ushort Type
        {
            get
            {
                return ((__Internal*)__Instance)->Type;
            }

            set
            {
                ((__Internal*)__Instance)->Type = value;
            }
        }

        public sbyte[] Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->Name, 100);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 100; i++)
                        ((__Internal*)__Instance)->Name[i] = value[i];
                }
            }
        }

        public int NormalMemory
        {
            get
            {
                return ((__Internal*)__Instance)->NormalMemory;
            }

            set
            {
                ((__Internal*)__Instance)->NormalMemory = value;
            }
        }

        public int MemoryBswaped
        {
            get
            {
                return ((__Internal*)__Instance)->MemoryBswaped;
            }

            set
            {
                ((__Internal*)__Instance)->MemoryBswaped = value;
            }
        }
    }

    public unsafe partial class RSP_INFO : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 224)]
        public partial struct __Internal
        {
            internal __IntPtr hinst;
            internal int MemoryBswaped;
            internal __IntPtr RDRAM;
            internal __IntPtr DMEM;
            internal __IntPtr IMEM;
            internal __IntPtr MI_INTR_REG;
            internal __IntPtr SP_MEM_ADDR_REG;
            internal __IntPtr SP_DRAM_ADDR_REG;
            internal __IntPtr SP_RD_LEN_REG;
            internal __IntPtr SP_WR_LEN_REG;
            internal __IntPtr SP_STATUS_REG;
            internal __IntPtr SP_DMA_FULL_REG;
            internal __IntPtr SP_DMA_BUSY_REG;
            internal __IntPtr SP_PC_REG;
            internal __IntPtr SP_SEMAPHORE_REG;
            internal __IntPtr DPC_START_REG;
            internal __IntPtr DPC_END_REG;
            internal __IntPtr DPC_CURRENT_REG;
            internal __IntPtr DPC_STATUS_REG;
            internal __IntPtr DPC_CLOCK_REG;
            internal __IntPtr DPC_BUFBUSY_REG;
            internal __IntPtr DPC_PIPEBUSY_REG;
            internal __IntPtr DPC_TMEM_REG;
            internal __IntPtr CheckInterrupts;
            internal __IntPtr ProcessDList;
            internal __IntPtr ProcessAList;
            internal __IntPtr ProcessRdpList;
            internal __IntPtr ShowCFB;

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "_ZN8RSP_INFOC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.Rsp.RSP_INFO> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.Rsp.RSP_INFO>();

        protected bool __ownsNativeInstance;

        internal static RSP_INFO __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RSP_INFO(native.ToPointer(), skipVTables);
        }

        internal static RSP_INFO __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RSP_INFO)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RSP_INFO __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RSP_INFO(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RSP_INFO(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RSP_INFO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RSP_INFO()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.Rsp.RSP_INFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RSP_INFO(global::RunN64.External.Rsp.RSP_INFO __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.Rsp.RSP_INFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::RunN64.External.Rsp.RSP_INFO.__Internal*) __Instance) = *((global::RunN64.External.Rsp.RSP_INFO.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr Hinst
        {
            get
            {
                return ((__Internal*)__Instance)->hinst;
            }

            set
            {
                ((__Internal*)__Instance)->hinst = (__IntPtr) value;
            }
        }

        public int MemoryBswaped
        {
            get
            {
                return ((__Internal*)__Instance)->MemoryBswaped;
            }

            set
            {
                ((__Internal*)__Instance)->MemoryBswaped = value;
            }
        }

        public byte* RDRAM
        {
            get
            {
                return (byte*)((__Internal*)__Instance)->RDRAM;
            }

            set
            {
                ((__Internal*)__Instance)->RDRAM = (__IntPtr) value;
            }
        }

        public byte* DMEM
        {
            get
            {
                return (byte*)((__Internal*)__Instance)->DMEM;
            }

            set
            {
                ((__Internal*)__Instance)->DMEM = (__IntPtr) value;
            }
        }

        public byte* IMEM
        {
            get
            {
                return (byte*)((__Internal*)__Instance)->IMEM;
            }

            set
            {
                ((__Internal*)__Instance)->IMEM = (__IntPtr) value;
            }
        }

        public uint* MI_INTR_REG
        {
            get
            {
                return (uint*)((__Internal*)__Instance)->MI_INTR_REG;
            }

            set
            {
                ((__Internal*)__Instance)->MI_INTR_REG = (__IntPtr) value;
            }
        }

        public uint* SP_MEM_ADDR_REG
        {
            get
            {
                return (uint*)((__Internal*)__Instance)->SP_MEM_ADDR_REG;
            }

            set
            {
                ((__Internal*)__Instance)->SP_MEM_ADDR_REG = (__IntPtr) value;
            }
        }

        public uint* SP_DRAM_ADDR_REG
        {
            get
            {
                return (uint*)((__Internal*)__Instance)->SP_DRAM_ADDR_REG;
            }

            set
            {
                ((__Internal*)__Instance)->SP_DRAM_ADDR_REG = (__IntPtr) value;
            }
        }

        public uint* SP_RD_LEN_REG
        {
            get
            {
                return (uint*)((__Internal*)__Instance)->SP_RD_LEN_REG;
            }

            set
            {
                ((__Internal*)__Instance)->SP_RD_LEN_REG = (__IntPtr) value;
            }
        }

        public uint* SP_WR_LEN_REG
        {
            get
            {
                return (uint*)((__Internal*)__Instance)->SP_WR_LEN_REG;
            }

            set
            {
                ((__Internal*)__Instance)->SP_WR_LEN_REG = (__IntPtr) value;
            }
        }

        public uint* SP_STATUS_REG
        {
            get
            {
                return (uint*)((__Internal*)__Instance)->SP_STATUS_REG;
            }

            set
            {
                ((__Internal*)__Instance)->SP_STATUS_REG = (__IntPtr) value;
            }
        }

        public uint* SP_DMA_FULL_REG
        {
            get
            {
                return (uint*)((__Internal*)__Instance)->SP_DMA_FULL_REG;
            }

            set
            {
                ((__Internal*)__Instance)->SP_DMA_FULL_REG = (__IntPtr) value;
            }
        }

        public uint* SP_DMA_BUSY_REG
        {
            get
            {
                return (uint*)((__Internal*)__Instance)->SP_DMA_BUSY_REG;
            }

            set
            {
                ((__Internal*)__Instance)->SP_DMA_BUSY_REG = (__IntPtr) value;
            }
        }

        public uint* SP_PC_REG
        {
            get
            {
                return (uint*)((__Internal*)__Instance)->SP_PC_REG;
            }

            set
            {
                ((__Internal*)__Instance)->SP_PC_REG = (__IntPtr) value;
            }
        }

        public uint* SP_SEMAPHORE_REG
        {
            get
            {
                return (uint*)((__Internal*)__Instance)->SP_SEMAPHORE_REG;
            }

            set
            {
                ((__Internal*)__Instance)->SP_SEMAPHORE_REG = (__IntPtr) value;
            }
        }

        public uint* DPC_START_REG
        {
            get
            {
                return (uint*)((__Internal*)__Instance)->DPC_START_REG;
            }

            set
            {
                ((__Internal*)__Instance)->DPC_START_REG = (__IntPtr) value;
            }
        }

        public uint* DPC_END_REG
        {
            get
            {
                return (uint*)((__Internal*)__Instance)->DPC_END_REG;
            }

            set
            {
                ((__Internal*)__Instance)->DPC_END_REG = (__IntPtr) value;
            }
        }

        public uint* DPC_CURRENT_REG
        {
            get
            {
                return (uint*)((__Internal*)__Instance)->DPC_CURRENT_REG;
            }

            set
            {
                ((__Internal*)__Instance)->DPC_CURRENT_REG = (__IntPtr) value;
            }
        }

        public uint* DPC_STATUS_REG
        {
            get
            {
                return (uint*)((__Internal*)__Instance)->DPC_STATUS_REG;
            }

            set
            {
                ((__Internal*)__Instance)->DPC_STATUS_REG = (__IntPtr) value;
            }
        }

        public uint* DPC_CLOCK_REG
        {
            get
            {
                return (uint*)((__Internal*)__Instance)->DPC_CLOCK_REG;
            }

            set
            {
                ((__Internal*)__Instance)->DPC_CLOCK_REG = (__IntPtr) value;
            }
        }

        public uint* DPC_BUFBUSY_REG
        {
            get
            {
                return (uint*)((__Internal*)__Instance)->DPC_BUFBUSY_REG;
            }

            set
            {
                ((__Internal*)__Instance)->DPC_BUFBUSY_REG = (__IntPtr) value;
            }
        }

        public uint* DPC_PIPEBUSY_REG
        {
            get
            {
                return (uint*)((__Internal*)__Instance)->DPC_PIPEBUSY_REG;
            }

            set
            {
                ((__Internal*)__Instance)->DPC_PIPEBUSY_REG = (__IntPtr) value;
            }
        }

        public uint* DPC_TMEM_REG
        {
            get
            {
                return (uint*)((__Internal*)__Instance)->DPC_TMEM_REG;
            }

            set
            {
                ((__Internal*)__Instance)->DPC_TMEM_REG = (__IntPtr) value;
            }
        }

        public global::RunN64.External.Rsp.PFunc CheckInterrupts
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->CheckInterrupts;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.Rsp.PFunc) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.Rsp.PFunc));
            }

            set
            {
                ((__Internal*)__Instance)->CheckInterrupts = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.Rsp.PFunc ProcessDList
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->ProcessDList;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.Rsp.PFunc) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.Rsp.PFunc));
            }

            set
            {
                ((__Internal*)__Instance)->ProcessDList = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.Rsp.PFunc ProcessAList
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->ProcessAList;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.Rsp.PFunc) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.Rsp.PFunc));
            }

            set
            {
                ((__Internal*)__Instance)->ProcessAList = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.Rsp.PFunc ProcessRdpList
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->ProcessRdpList;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.Rsp.PFunc) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.Rsp.PFunc));
            }

            set
            {
                ((__Internal*)__Instance)->ProcessRdpList = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.Rsp.PFunc ShowCFB
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->ShowCFB;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.Rsp.PFunc) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.Rsp.PFunc));
            }

            set
            {
                ((__Internal*)__Instance)->ShowCFB = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class RSPDEBUG_INFO : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 112)]
        public partial struct __Internal
        {
            internal __IntPtr hRSPMenu;
            internal __IntPtr ProcessMenuItem;
            internal int UseBPoints;
            internal fixed sbyte BPPanelName[20];
            internal __IntPtr Add_BPoint;
            internal __IntPtr CreateBPPanel;
            internal __IntPtr HideBPPanel;
            internal __IntPtr PaintBPPanel;
            internal __IntPtr ShowBPPanel;
            internal __IntPtr RefreshBpoints;
            internal __IntPtr RemoveBpoint;
            internal __IntPtr RemoveAllBpoint;
            internal __IntPtr Enter_RSP_Commands_Window;

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "_ZN13RSPDEBUG_INFOC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.Rsp.RSPDEBUG_INFO> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.Rsp.RSPDEBUG_INFO>();

        protected bool __ownsNativeInstance;

        internal static RSPDEBUG_INFO __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new RSPDEBUG_INFO(native.ToPointer(), skipVTables);
        }

        internal static RSPDEBUG_INFO __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (RSPDEBUG_INFO)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static RSPDEBUG_INFO __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new RSPDEBUG_INFO(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private RSPDEBUG_INFO(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected RSPDEBUG_INFO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public RSPDEBUG_INFO()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.Rsp.RSPDEBUG_INFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public RSPDEBUG_INFO(global::RunN64.External.Rsp.RSPDEBUG_INFO __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.Rsp.RSPDEBUG_INFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::RunN64.External.Rsp.RSPDEBUG_INFO.__Internal*) __Instance) = *((global::RunN64.External.Rsp.RSPDEBUG_INFO.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr HRSPMenu
        {
            get
            {
                return ((__Internal*)__Instance)->hRSPMenu;
            }

            set
            {
                ((__Internal*)__Instance)->hRSPMenu = (__IntPtr) value;
            }
        }

        public global::RunN64.External.Rsp.Delegates.Action_int ProcessMenuItem
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->ProcessMenuItem;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.Rsp.Delegates.Action_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.Rsp.Delegates.Action_int));
            }

            set
            {
                ((__Internal*)__Instance)->ProcessMenuItem = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public int UseBPoints
        {
            get
            {
                return ((__Internal*)__Instance)->UseBPoints;
            }

            set
            {
                ((__Internal*)__Instance)->UseBPoints = value;
            }
        }

        public sbyte[] BPPanelName
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->BPPanelName, 20);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 20; i++)
                        ((__Internal*)__Instance)->BPPanelName[i] = value[i];
                }
            }
        }

        public global::RunN64.External.Rsp.PFunc AddBPoint
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Add_BPoint;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.Rsp.PFunc) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.Rsp.PFunc));
            }

            set
            {
                ((__Internal*)__Instance)->Add_BPoint = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.Rsp.Delegates.Action___IntPtr_RunN64_External_Rsp_winapi_rect___Internal CreateBPPanel
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->CreateBPPanel;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.Rsp.Delegates.Action___IntPtr_RunN64_External_Rsp_winapi_rect___Internal) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.Rsp.Delegates.Action___IntPtr_RunN64_External_Rsp_winapi_rect___Internal));
            }

            set
            {
                ((__Internal*)__Instance)->CreateBPPanel = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.Rsp.PFunc HideBPPanel
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->HideBPPanel;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.Rsp.PFunc) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.Rsp.PFunc));
            }

            set
            {
                ((__Internal*)__Instance)->HideBPPanel = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.Rsp.Delegates.Action_RunN64_External_Rsp_winapi_paintstruct___Internal PaintBPPanel
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->PaintBPPanel;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.Rsp.Delegates.Action_RunN64_External_Rsp_winapi_paintstruct___Internal) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.Rsp.Delegates.Action_RunN64_External_Rsp_winapi_paintstruct___Internal));
            }

            set
            {
                ((__Internal*)__Instance)->PaintBPPanel = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr ShowBPPanel
        {
            get
            {
                return ((__Internal*)__Instance)->ShowBPPanel;
            }

            set
            {
                ((__Internal*)__Instance)->ShowBPPanel = (__IntPtr) value;
            }
        }

        public global::RunN64.External.Rsp.Delegates.Action___IntPtr RefreshBpoints
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->RefreshBpoints;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.Rsp.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.Rsp.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->RefreshBpoints = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.Rsp.Delegates.Action___IntPtr_int RemoveBpoint
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->RemoveBpoint;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.Rsp.Delegates.Action___IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.Rsp.Delegates.Action___IntPtr_int));
            }

            set
            {
                ((__Internal*)__Instance)->RemoveBpoint = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr RemoveAllBpoint
        {
            get
            {
                return ((__Internal*)__Instance)->RemoveAllBpoint;
            }

            set
            {
                ((__Internal*)__Instance)->RemoveAllBpoint = (__IntPtr) value;
            }
        }

        public global::RunN64.External.Rsp.PFunc EnterRSP_CommandsWindow
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Enter_RSP_Commands_Window;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.Rsp.PFunc) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.Rsp.PFunc));
            }

            set
            {
                ((__Internal*)__Instance)->Enter_RSP_Commands_Window = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class DEBUG_INFO : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal __IntPtr UpdateBreakPoints;
            internal __IntPtr UpdateMemory;
            internal __IntPtr UpdateR4300iRegisters;
            internal __IntPtr Enter_BPoint_Window;
            internal __IntPtr Enter_R4300i_Commands_Window;
            internal __IntPtr Enter_R4300i_Register_Window;
            internal __IntPtr Enter_RSP_Commands_Window;
            internal __IntPtr Enter_Memory_Window;

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "_ZN10DEBUG_INFOC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.Rsp.DEBUG_INFO> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.Rsp.DEBUG_INFO>();

        protected bool __ownsNativeInstance;

        internal static DEBUG_INFO __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new DEBUG_INFO(native.ToPointer(), skipVTables);
        }

        internal static DEBUG_INFO __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (DEBUG_INFO)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static DEBUG_INFO __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new DEBUG_INFO(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private DEBUG_INFO(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected DEBUG_INFO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public DEBUG_INFO()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.Rsp.DEBUG_INFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public DEBUG_INFO(global::RunN64.External.Rsp.DEBUG_INFO __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.Rsp.DEBUG_INFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::RunN64.External.Rsp.DEBUG_INFO.__Internal*) __Instance) = *((global::RunN64.External.Rsp.DEBUG_INFO.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::RunN64.External.Rsp.PFunc UpdateBreakPoints
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->UpdateBreakPoints;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.Rsp.PFunc) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.Rsp.PFunc));
            }

            set
            {
                ((__Internal*)__Instance)->UpdateBreakPoints = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.Rsp.PFunc UpdateMemory
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->UpdateMemory;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.Rsp.PFunc) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.Rsp.PFunc));
            }

            set
            {
                ((__Internal*)__Instance)->UpdateMemory = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.Rsp.PFunc UpdateR4300iRegisters
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->UpdateR4300iRegisters;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.Rsp.PFunc) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.Rsp.PFunc));
            }

            set
            {
                ((__Internal*)__Instance)->UpdateR4300iRegisters = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.Rsp.PFunc EnterBPointWindow
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Enter_BPoint_Window;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.Rsp.PFunc) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.Rsp.PFunc));
            }

            set
            {
                ((__Internal*)__Instance)->Enter_BPoint_Window = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.Rsp.PFunc EnterR4300iCommandsWindow
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Enter_R4300i_Commands_Window;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.Rsp.PFunc) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.Rsp.PFunc));
            }

            set
            {
                ((__Internal*)__Instance)->Enter_R4300i_Commands_Window = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.Rsp.PFunc EnterR4300iRegisterWindow
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Enter_R4300i_Register_Window;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.Rsp.PFunc) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.Rsp.PFunc));
            }

            set
            {
                ((__Internal*)__Instance)->Enter_R4300i_Register_Window = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.Rsp.PFunc EnterRSP_CommandsWindow
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Enter_RSP_Commands_Window;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.Rsp.PFunc) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.Rsp.PFunc));
            }

            set
            {
                ((__Internal*)__Instance)->Enter_RSP_Commands_Window = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.Rsp.PFunc EnterMemoryWindow
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Enter_Memory_Window;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.Rsp.PFunc) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.Rsp.PFunc));
            }

            set
            {
                ((__Internal*)__Instance)->Enter_Memory_Window = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class SHARE_STATE : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal __IntPtr VectorRegisters;
            internal __IntPtr Accumulator;
            internal __IntPtr SURegisters;

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "_ZN11SHARE_STATEC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.Rsp.SHARE_STATE> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.Rsp.SHARE_STATE>();

        protected bool __ownsNativeInstance;

        internal static SHARE_STATE __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SHARE_STATE(native.ToPointer(), skipVTables);
        }

        internal static SHARE_STATE __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (SHARE_STATE)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static SHARE_STATE __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SHARE_STATE(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SHARE_STATE(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SHARE_STATE(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public SHARE_STATE()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.Rsp.SHARE_STATE.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public SHARE_STATE(global::RunN64.External.Rsp.SHARE_STATE __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.Rsp.SHARE_STATE.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::RunN64.External.Rsp.SHARE_STATE.__Internal*) __Instance) = *((global::RunN64.External.Rsp.SHARE_STATE.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        public virtual void Dispose(bool disposing)
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte* VectorRegisters
        {
            get
            {
                return (byte*)((__Internal*)__Instance)->VectorRegisters;
            }

            set
            {
                ((__Internal*)__Instance)->VectorRegisters = (__IntPtr) value;
            }
        }

        public byte* Accumulator
        {
            get
            {
                return (byte*)((__Internal*)__Instance)->Accumulator;
            }

            set
            {
                ((__Internal*)__Instance)->Accumulator = (__IntPtr) value;
            }
        }

        public byte* SURegisters
        {
            get
            {
                return (byte*)((__Internal*)__Instance)->SURegisters;
            }

            set
            {
                ((__Internal*)__Instance)->SURegisters = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class rsp
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "CloseDLL", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CloseDLL();

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "DllAbout", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DllAbout(__IntPtr hParent);

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "DllConfig", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DllConfig(__IntPtr hParent);

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "DllTest", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DllTest(__IntPtr hParent);

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "DoRspCycles", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern uint DoRspCycles(uint Cycles);

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "GetDllInfo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetDllInfo(__IntPtr PluginInfo);

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "GetRspDebugInfo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetRspDebugInfo(__IntPtr RSPDebugInfo);

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "InitiateRSP", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void InitiateRSP(global::RunN64.External.Rsp.RSP_INFO.__Internal Rsp_Info, uint* CycleCount);

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "InitiateRSPDebugger", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void InitiateRSPDebugger(global::RunN64.External.Rsp.DEBUG_INFO.__Internal DebugInfo);

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "RomClosed", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void RomClosed();

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "SetInstDebugHandler", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetInstDebugHandler(__IntPtr callback);

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "GetCoreState", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetCoreState(__IntPtr @return);

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "SingleStep", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SingleStep();

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "GetVc0", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort GetVc0();

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "GetVcc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern ushort GetVcc();

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "GetVce", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern byte GetVce();

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "SetVc0", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetVc0(ushort value);

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "SetVcc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetVcc(ushort value);

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "SetVce", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void SetVce(byte value);

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "RomOpen", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void RomOpen();

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "EnableDebugging", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void EnableDebugging(int Enabled);

            [SuppressUnmanagedCodeSecurity, DllImport("rsp.so", EntryPoint = "PluginLoaded", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void PluginLoaded();
        }

        /// <summary>
        /// <para>****************************************************************************</para>
        /// <para>name     :  CloseDLL</para>
        /// <para>optional :  no</para>
        /// <para>call time:  when the emulator is shutting down or chooses to free memory</para>
        /// <para>input    :  none</para>
        /// <para>output   :  none</para>
        /// <para>*****************************************************************************</para>
        /// </summary>
        public static void CloseDLL()
        {
            __Internal.CloseDLL();
        }

        /// <summary>
        /// <para>****************************************************************************</para>
        /// <para>name     :  DllAbout</para>
        /// <para>optional :  yes</para>
        /// <para>call time:  upon a request to see information about the plugin (e.g., authors)</para>
        /// <para>input    :  a pointer to the window that called this function</para>
        /// <para>output   :  none</para>
        /// <para>*****************************************************************************</para>
        /// </summary>
        public static void DllAbout(__IntPtr hParent)
        {
            __Internal.DllAbout(hParent);
        }

        /// <summary>
        /// <para>****************************************************************************</para>
        /// <para>name     :  DllConfig</para>
        /// <para>optional :  yes</para>
        /// <para>call time:  upon a request to configure the plugin (e.g., change settings)</para>
        /// <para>input    :  a pointer to the window that called this function</para>
        /// <para>output   :  none</para>
        /// <para>*****************************************************************************</para>
        /// </summary>
        public static void DllConfig(__IntPtr hParent)
        {
            __Internal.DllConfig(hParent);
        }

        /// <summary>
        /// <para>****************************************************************************</para>
        /// <para>name     :  DllTest</para>
        /// <para>optional :  yes</para>
        /// <para>call time:  upon a request to test the plugin (e.g., system capabilities)</para>
        /// <para>input    :  a pointer to the window that called this function</para>
        /// <para>output   :  none</para>
        /// <para>*****************************************************************************</para>
        /// </summary>
        public static void DllTest(__IntPtr hParent)
        {
            __Internal.DllTest(hParent);
        }

        /// <summary>
        /// <para>****************************************************************************</para>
        /// <para>name     :  DoRspCycles</para>
        /// <para>optional :  no</para>
        /// <para>call time:  when the R4300 CPU alternates control to execute on the RSP</para>
        /// <para>input    :  number of cycles meant to be executed (for segmented execution)</para>
        /// <para>output   :  The number of cycles executed also was intended for cycle-timing</para>
        /// <para>attempts, much like Project64 itself originally was, and requires</para>
        /// <para>individual experiment.  This value is ignored if the RSP CPU flow</para>
        /// <para>was halted when the function completed.  In-depth debate:</para>
        /// <para>http://www.emutalk.net/showthread.php?t=43088</para>
        /// <para>*****************************************************************************</para>
        /// </summary>
        public static uint DoRspCycles(uint Cycles)
        {
            var __ret = __Internal.DoRspCycles(Cycles);
            return __ret;
        }

        /// <summary>
        /// <para>****************************************************************************</para>
        /// <para>name     :  GetDllInfo</para>
        /// <para>optional :  no</para>
        /// <para>call time:  during the enumeration of valid plugins the emulator can load</para>
        /// <para>input    :  a pointer to a PLUGIN_INFO stucture used to determine support</para>
        /// <para>output   :  none</para>
        /// <para>*****************************************************************************</para>
        /// </summary>
        public static void GetDllInfo(global::RunN64.External.Rsp.PLUGIN_INFO PluginInfo)
        {
            var __arg0 = PluginInfo is null ? __IntPtr.Zero : PluginInfo.__Instance;
            __Internal.GetDllInfo(__arg0);
        }

        /// <summary>
        /// <para>****************************************************************************</para>
        /// <para>name     :  GetRspDebugInfo</para>
        /// <para>optional :  yes</para>
        /// <para>call time:  when the emulator requests information about what the RSP plugin</para>
        /// <para>is and is not programmed to debug</para>
        /// <para>input    :  a pointer to a RSPDEBUG_INFO stucture to determine capabilities</para>
        /// <para>output   :  none</para>
        /// <para>*****************************************************************************</para>
        /// </summary>
        public static void GetRspDebugInfo(global::RunN64.External.Rsp.RSPDEBUG_INFO RSPDebugInfo)
        {
            var __arg0 = RSPDebugInfo is null ? __IntPtr.Zero : RSPDebugInfo.__Instance;
            __Internal.GetRspDebugInfo(__arg0);
        }

        /// <summary>
        /// <para>****************************************************************************</para>
        /// <para>name     :  InitiateRSP</para>
        /// <para>optional :  no</para>
        /// <para>call time:  after the emulator has successfully loaded the plugin but needs</para>
        /// <para>more information about it before proceeding to start emulation</para>
        /// <para>input    :  a RSP_INFO structure mostly for setting up the RCP memory map</para>
        /// <para>output   :  none</para>
        /// <para>*****************************************************************************</para>
        /// </summary>
        public static void InitiateRSP(global::RunN64.External.Rsp.RSP_INFO Rsp_Info, ref uint CycleCount)
        {
            if (ReferenceEquals(Rsp_Info, null))
                throw new global::System.ArgumentNullException("Rsp_Info", "Cannot be null because it is passed by value.");
            var __arg0 = Rsp_Info.__Instance;
            fixed (uint* __CycleCount1 = &CycleCount)
            {
                var __arg1 = __CycleCount1;
                __Internal.InitiateRSP(*(global::RunN64.External.Rsp.RSP_INFO.__Internal*) __arg0, __arg1);
            }
        }

        /// <summary>
        /// <para>****************************************************************************</para>
        /// <para>name     :  InitiateRSPDebugger</para>
        /// <para>optional :  yes</para>
        /// <para>call time:  after plugin load, when the emulator is ready to supply an</para>
        /// <para>informational structure useful to the RSP plugin for integrating</para>
        /// <para>its debugger, if any, with the rest of the emulator</para>
        /// <para>input    :  a DEBUG_INFO structure offering debugger integration information</para>
        /// <para>output   :  none</para>
        /// <para>*****************************************************************************</para>
        /// </summary>
        public static void InitiateRSPDebugger(global::RunN64.External.Rsp.DEBUG_INFO DebugInfo)
        {
            if (ReferenceEquals(DebugInfo, null))
                throw new global::System.ArgumentNullException("DebugInfo", "Cannot be null because it is passed by value.");
            var __arg0 = DebugInfo.__Instance;
            __Internal.InitiateRSPDebugger(*(global::RunN64.External.Rsp.DEBUG_INFO.__Internal*) __arg0);
        }

        /// <summary>
        /// <para>****************************************************************************</para>
        /// <para>name     :  RomClosed</para>
        /// <para>optional :  no</para>
        /// <para>call time:  when unloading the ROM (sometimes when emulation ends)</para>
        /// <para>input    :  none</para>
        /// <para>output   :  none</para>
        /// <para>*****************************************************************************</para>
        /// </summary>
        public static void RomClosed()
        {
            __Internal.RomClosed();
        }

        public static void SetInstDebugHandler(global::RunN64.External.Rsp.InstDebugFunc callback)
        {
            var __arg0 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            __Internal.SetInstDebugHandler(__arg0);
        }

        public static global::RunN64.External.Rsp.SHARE_STATE GetCoreState()
        {
            var __ret = new global::RunN64.External.Rsp.SHARE_STATE.__Internal();
            __Internal.GetCoreState(new IntPtr(&__ret));
            return global::RunN64.External.Rsp.SHARE_STATE.__CreateInstance(__ret);
        }

        public static void SingleStep()
        {
            __Internal.SingleStep();
        }

        public static ushort GetVc0()
        {
            var __ret = __Internal.GetVc0();
            return __ret;
        }

        public static ushort GetVcc()
        {
            var __ret = __Internal.GetVcc();
            return __ret;
        }

        public static byte GetVce()
        {
            var __ret = __Internal.GetVce();
            return __ret;
        }

        public static void SetVc0(ushort value)
        {
            __Internal.SetVc0(value);
        }

        public static void SetVcc(ushort value)
        {
            __Internal.SetVcc(value);
        }

        public static void SetVce(byte value)
        {
            __Internal.SetVce(value);
        }

        public static void RomOpen()
        {
            __Internal.RomOpen();
        }

        public static void EnableDebugging(int Enabled)
        {
            __Internal.EnableDebugging(Enabled);
        }

        public static void PluginLoaded()
        {
            __Internal.PluginLoaded();
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_int(int ID);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_RunN64_External_Rsp_winapi_rect___Internal(__IntPtr hDlg, global::RunN64.External.Rsp.WinapiRect.__Internal rcBox);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_RunN64_External_Rsp_winapi_paintstruct___Internal(global::RunN64.External.Rsp.WinapiPaintstruct.__Internal ps);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr(__IntPtr hList);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_int(__IntPtr hList, int index);
    }
}
namespace RunN64.External.Rsp.__Symbols
{
    internal class rsp_so
    {
        public static IntPtr _GBI_phase { get; }
        static rsp_so()
        {
            var path = "rsp.so";
            var image = CppSharp.SymbolResolver.LoadImage(ref path);
            if (image == IntPtr.Zero) throw new System.DllNotFoundException(path);
            _GBI_phase = CppSharp.SymbolResolver.ResolveSymbol(image, "GBI_phase");
        }
    }
}

