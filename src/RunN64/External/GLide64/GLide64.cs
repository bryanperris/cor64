// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace RunN64.External.GLide64
{
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void PFunc();

    /// <summary>*** Structures ****</summary>
    /// <summary>*** Structures ****</summary>
    public unsafe partial class PLUGIN_INFO : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 112)]
        public partial struct __Internal
        {
            internal ushort Version;
            internal ushort Type;
            internal fixed sbyte Name[100];
            internal int NormalMemory;
            internal int MemoryBswaped;

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "_ZN11PLUGIN_INFOC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.GLide64.PLUGIN_INFO> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.GLide64.PLUGIN_INFO>();

        protected bool __ownsNativeInstance;

        internal static PLUGIN_INFO __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new PLUGIN_INFO(native.ToPointer(), skipVTables);
        }

        internal static PLUGIN_INFO __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (PLUGIN_INFO)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static PLUGIN_INFO __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new PLUGIN_INFO(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private PLUGIN_INFO(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected PLUGIN_INFO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public PLUGIN_INFO()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.GLide64.PLUGIN_INFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public PLUGIN_INFO(global::RunN64.External.GLide64.PLUGIN_INFO __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.GLide64.PLUGIN_INFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::RunN64.External.GLide64.PLUGIN_INFO.__Internal*) __Instance) = *((global::RunN64.External.GLide64.PLUGIN_INFO.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort Version
        {
            get
            {
                return ((__Internal*)__Instance)->Version;
            }

            set
            {
                ((__Internal*)__Instance)->Version = value;
            }
        }

        public ushort Type
        {
            get
            {
                return ((__Internal*)__Instance)->Type;
            }

            set
            {
                ((__Internal*)__Instance)->Type = value;
            }
        }

        public sbyte[] Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->Name, 100);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 100; i++)
                        ((__Internal*)__Instance)->Name[i] = value[i];
                }
            }
        }

        public int NormalMemory
        {
            get
            {
                return ((__Internal*)__Instance)->NormalMemory;
            }

            set
            {
                ((__Internal*)__Instance)->NormalMemory = value;
            }
        }

        public int MemoryBswaped
        {
            get
            {
                return ((__Internal*)__Instance)->MemoryBswaped;
            }

            set
            {
                ((__Internal*)__Instance)->MemoryBswaped = value;
            }
        }
    }

    public unsafe partial class COR64GFX_INFO : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 256)]
        public partial struct __Internal
        {
            internal __IntPtr hWnd;
            internal __IntPtr hStatusBar;
            internal int MemoryBswaped;
            internal __IntPtr HEADER;
            internal __IntPtr RDRAM;
            internal __IntPtr DMEM;
            internal __IntPtr IMEM;
            internal __IntPtr MI_INTR_REG;
            internal __IntPtr DPC_START_REG;
            internal __IntPtr DPC_END_REG;
            internal __IntPtr DPC_CURRENT_REG;
            internal __IntPtr DPC_STATUS_REG;
            internal __IntPtr DPC_CLOCK_REG;
            internal __IntPtr DPC_BUFBUSY_REG;
            internal __IntPtr DPC_PIPEBUSY_REG;
            internal __IntPtr DPC_TMEM_REG;
            internal __IntPtr VI_STATUS_REG;
            internal __IntPtr VI_ORIGIN_REG;
            internal __IntPtr VI_WIDTH_REG;
            internal __IntPtr VI_INTR_REG;
            internal __IntPtr VI_V_CURRENT_LINE_REG;
            internal __IntPtr VI_TIMING_REG;
            internal __IntPtr VI_V_SYNC_REG;
            internal __IntPtr VI_H_SYNC_REG;
            internal __IntPtr VI_LEAP_REG;
            internal __IntPtr VI_H_START_REG;
            internal __IntPtr VI_V_START_REG;
            internal __IntPtr VI_V_BURST_REG;
            internal __IntPtr VI_X_SCALE_REG;
            internal __IntPtr VI_Y_SCALE_REG;
            internal __IntPtr SP_STATUS;
            internal __IntPtr CheckInterrupts;

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "_ZN14COR64_GFX_INFOC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.GLide64.COR64GFX_INFO> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.GLide64.COR64GFX_INFO>();

        protected bool __ownsNativeInstance;

        internal static COR64GFX_INFO __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new COR64GFX_INFO(native.ToPointer(), skipVTables);
        }

        internal static COR64GFX_INFO __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (COR64GFX_INFO)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static COR64GFX_INFO __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new COR64GFX_INFO(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private COR64GFX_INFO(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected COR64GFX_INFO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public COR64GFX_INFO()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.GLide64.COR64GFX_INFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public COR64GFX_INFO(global::RunN64.External.GLide64.COR64GFX_INFO __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.GLide64.COR64GFX_INFO.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::RunN64.External.GLide64.COR64GFX_INFO.__Internal*) __Instance) = *((global::RunN64.External.GLide64.COR64GFX_INFO.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr HWnd
        {
            get
            {
                return ((__Internal*)__Instance)->hWnd;
            }

            set
            {
                ((__Internal*)__Instance)->hWnd = (__IntPtr) value;
            }
        }

        public __IntPtr HStatusBar
        {
            get
            {
                return ((__Internal*)__Instance)->hStatusBar;
            }

            set
            {
                ((__Internal*)__Instance)->hStatusBar = (__IntPtr) value;
            }
        }

        public int MemoryBswaped
        {
            get
            {
                return ((__Internal*)__Instance)->MemoryBswaped;
            }

            set
            {
                ((__Internal*)__Instance)->MemoryBswaped = value;
            }
        }

        public byte* HEADER
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->HEADER;
            }

            set
            {
                ((__Internal*)__Instance)->HEADER = (__IntPtr) value;
            }
        }

        public byte* RDRAM
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->RDRAM;
            }

            set
            {
                ((__Internal*)__Instance)->RDRAM = (__IntPtr) value;
            }
        }

        public byte* DMEM
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->DMEM;
            }

            set
            {
                ((__Internal*)__Instance)->DMEM = (__IntPtr) value;
            }
        }

        public byte* IMEM
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->IMEM;
            }

            set
            {
                ((__Internal*)__Instance)->IMEM = (__IntPtr) value;
            }
        }

        public uint* MI_INTR_REG
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->MI_INTR_REG;
            }

            set
            {
                ((__Internal*)__Instance)->MI_INTR_REG = (__IntPtr) value;
            }
        }

        public uint* DPC_START_REG
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->DPC_START_REG;
            }

            set
            {
                ((__Internal*)__Instance)->DPC_START_REG = (__IntPtr) value;
            }
        }

        public uint* DPC_END_REG
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->DPC_END_REG;
            }

            set
            {
                ((__Internal*)__Instance)->DPC_END_REG = (__IntPtr) value;
            }
        }

        public uint* DPC_CURRENT_REG
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->DPC_CURRENT_REG;
            }

            set
            {
                ((__Internal*)__Instance)->DPC_CURRENT_REG = (__IntPtr) value;
            }
        }

        public uint* DPC_STATUS_REG
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->DPC_STATUS_REG;
            }

            set
            {
                ((__Internal*)__Instance)->DPC_STATUS_REG = (__IntPtr) value;
            }
        }

        public uint* DPC_CLOCK_REG
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->DPC_CLOCK_REG;
            }

            set
            {
                ((__Internal*)__Instance)->DPC_CLOCK_REG = (__IntPtr) value;
            }
        }

        public uint* DPC_BUFBUSY_REG
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->DPC_BUFBUSY_REG;
            }

            set
            {
                ((__Internal*)__Instance)->DPC_BUFBUSY_REG = (__IntPtr) value;
            }
        }

        public uint* DPC_PIPEBUSY_REG
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->DPC_PIPEBUSY_REG;
            }

            set
            {
                ((__Internal*)__Instance)->DPC_PIPEBUSY_REG = (__IntPtr) value;
            }
        }

        public uint* DPC_TMEM_REG
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->DPC_TMEM_REG;
            }

            set
            {
                ((__Internal*)__Instance)->DPC_TMEM_REG = (__IntPtr) value;
            }
        }

        public uint* VI_STATUS_REG
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->VI_STATUS_REG;
            }

            set
            {
                ((__Internal*)__Instance)->VI_STATUS_REG = (__IntPtr) value;
            }
        }

        public uint* VI_ORIGIN_REG
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->VI_ORIGIN_REG;
            }

            set
            {
                ((__Internal*)__Instance)->VI_ORIGIN_REG = (__IntPtr) value;
            }
        }

        public uint* VI_WIDTH_REG
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->VI_WIDTH_REG;
            }

            set
            {
                ((__Internal*)__Instance)->VI_WIDTH_REG = (__IntPtr) value;
            }
        }

        public uint* VI_INTR_REG
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->VI_INTR_REG;
            }

            set
            {
                ((__Internal*)__Instance)->VI_INTR_REG = (__IntPtr) value;
            }
        }

        public uint* VI_V_CURRENT_LINE_REG
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->VI_V_CURRENT_LINE_REG;
            }

            set
            {
                ((__Internal*)__Instance)->VI_V_CURRENT_LINE_REG = (__IntPtr) value;
            }
        }

        public uint* VI_TIMING_REG
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->VI_TIMING_REG;
            }

            set
            {
                ((__Internal*)__Instance)->VI_TIMING_REG = (__IntPtr) value;
            }
        }

        public uint* VI_V_SYNC_REG
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->VI_V_SYNC_REG;
            }

            set
            {
                ((__Internal*)__Instance)->VI_V_SYNC_REG = (__IntPtr) value;
            }
        }

        public uint* VI_H_SYNC_REG
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->VI_H_SYNC_REG;
            }

            set
            {
                ((__Internal*)__Instance)->VI_H_SYNC_REG = (__IntPtr) value;
            }
        }

        public uint* VI_LEAP_REG
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->VI_LEAP_REG;
            }

            set
            {
                ((__Internal*)__Instance)->VI_LEAP_REG = (__IntPtr) value;
            }
        }

        public uint* VI_H_START_REG
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->VI_H_START_REG;
            }

            set
            {
                ((__Internal*)__Instance)->VI_H_START_REG = (__IntPtr) value;
            }
        }

        public uint* VI_V_START_REG
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->VI_V_START_REG;
            }

            set
            {
                ((__Internal*)__Instance)->VI_V_START_REG = (__IntPtr) value;
            }
        }

        public uint* VI_V_BURST_REG
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->VI_V_BURST_REG;
            }

            set
            {
                ((__Internal*)__Instance)->VI_V_BURST_REG = (__IntPtr) value;
            }
        }

        public uint* VI_X_SCALE_REG
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->VI_X_SCALE_REG;
            }

            set
            {
                ((__Internal*)__Instance)->VI_X_SCALE_REG = (__IntPtr) value;
            }
        }

        public uint* VI_Y_SCALE_REG
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->VI_Y_SCALE_REG;
            }

            set
            {
                ((__Internal*)__Instance)->VI_Y_SCALE_REG = (__IntPtr) value;
            }
        }

        public uint* SP_STATUS
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->SP_STATUS;
            }

            set
            {
                ((__Internal*)__Instance)->SP_STATUS = (__IntPtr) value;
            }
        }

        public global::RunN64.External.GLide64.PFunc CheckInterrupts
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->CheckInterrupts;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.PFunc) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.PFunc));
            }

            set
            {
                ((__Internal*)__Instance)->CheckInterrupts = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class MUPEN_VID_EXT : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 112)]
        public partial struct __Internal
        {
            internal __IntPtr CoreVideo_Init;
            internal __IntPtr CoreVideo_Quit;
            internal __IntPtr CoreVideo_ListFullscreenModes;
            internal __IntPtr CoreVideo_ListFullscreenRates;
            internal __IntPtr CoreVideo_SetVideoMode;
            internal __IntPtr CoreVideo_SetVideoModeWithRate;
            internal __IntPtr CoreVideo_SetCaption;
            internal __IntPtr CoreVideo_ToggleFullScreen;
            internal __IntPtr CoreVideo_ResizeWindow;
            internal __IntPtr CoreVideo_GL_GetProcAddress;
            internal __IntPtr CoreVideo_GL_SetAttribute;
            internal __IntPtr CoreVideo_GL_GetAttribute;
            internal __IntPtr CoreVideo_GL_SwapBuffers;
            internal __IntPtr CoreVideo_GL_GetDefaultFramebuffer;

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "_ZN13MUPEN_VID_EXTC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.GLide64.MUPEN_VID_EXT> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.GLide64.MUPEN_VID_EXT>();

        protected bool __ownsNativeInstance;

        internal static MUPEN_VID_EXT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new MUPEN_VID_EXT(native.ToPointer(), skipVTables);
        }

        internal static MUPEN_VID_EXT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (MUPEN_VID_EXT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static MUPEN_VID_EXT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new MUPEN_VID_EXT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private MUPEN_VID_EXT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected MUPEN_VID_EXT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public MUPEN_VID_EXT()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.GLide64.MUPEN_VID_EXT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public MUPEN_VID_EXT(global::RunN64.External.GLide64.MUPEN_VID_EXT __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.GLide64.MUPEN_VID_EXT.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::RunN64.External.GLide64.MUPEN_VID_EXT.__Internal*) __Instance) = *((global::RunN64.External.GLide64.MUPEN_VID_EXT.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::RunN64.External.GLide64.PtrVidExtInit CoreVideoInit
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->CoreVideo_Init;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.PtrVidExtInit) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.PtrVidExtInit));
            }

            set
            {
                ((__Internal*)__Instance)->CoreVideo_Init = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.PtrVidExtQuit CoreVideoQuit
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->CoreVideo_Quit;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.PtrVidExtQuit) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.PtrVidExtQuit));
            }

            set
            {
                ((__Internal*)__Instance)->CoreVideo_Quit = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.PtrVidExtListFullscreenModes CoreVideoListFullscreenModes
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->CoreVideo_ListFullscreenModes;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.PtrVidExtListFullscreenModes) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.PtrVidExtListFullscreenModes));
            }

            set
            {
                ((__Internal*)__Instance)->CoreVideo_ListFullscreenModes = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.PtrVidExtListFullscreenRates CoreVideoListFullscreenRates
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->CoreVideo_ListFullscreenRates;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.PtrVidExtListFullscreenRates) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.PtrVidExtListFullscreenRates));
            }

            set
            {
                ((__Internal*)__Instance)->CoreVideo_ListFullscreenRates = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.PtrVidExtSetVideoMode CoreVideoSetVideoMode
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->CoreVideo_SetVideoMode;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.PtrVidExtSetVideoMode) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.PtrVidExtSetVideoMode));
            }

            set
            {
                ((__Internal*)__Instance)->CoreVideo_SetVideoMode = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.PtrVidExtSetVideoModeWithRate CoreVideoSetVideoModeWithRate
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->CoreVideo_SetVideoModeWithRate;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.PtrVidExtSetVideoModeWithRate) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.PtrVidExtSetVideoModeWithRate));
            }

            set
            {
                ((__Internal*)__Instance)->CoreVideo_SetVideoModeWithRate = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.PtrVidExtSetCaption CoreVideoSetCaption
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->CoreVideo_SetCaption;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.PtrVidExtSetCaption) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.PtrVidExtSetCaption));
            }

            set
            {
                ((__Internal*)__Instance)->CoreVideo_SetCaption = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.PtrVidExtToggleFullScreen CoreVideoToggleFullScreen
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->CoreVideo_ToggleFullScreen;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.PtrVidExtToggleFullScreen) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.PtrVidExtToggleFullScreen));
            }

            set
            {
                ((__Internal*)__Instance)->CoreVideo_ToggleFullScreen = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.PtrVidExtResizeWindow CoreVideoResizeWindow
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->CoreVideo_ResizeWindow;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.PtrVidExtResizeWindow) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.PtrVidExtResizeWindow));
            }

            set
            {
                ((__Internal*)__Instance)->CoreVideo_ResizeWindow = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.PtrVidExtGL_GetProcAddress CoreVideoGL_GetProcAddress
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->CoreVideo_GL_GetProcAddress;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.PtrVidExtGL_GetProcAddress) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.PtrVidExtGL_GetProcAddress));
            }

            set
            {
                ((__Internal*)__Instance)->CoreVideo_GL_GetProcAddress = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.PtrVidExtGL_SetAttribute CoreVideoGL_SetAttribute
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->CoreVideo_GL_SetAttribute;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.PtrVidExtGL_SetAttribute) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.PtrVidExtGL_SetAttribute));
            }

            set
            {
                ((__Internal*)__Instance)->CoreVideo_GL_SetAttribute = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.PtrVidExtGL_GetAttribute CoreVideoGL_GetAttribute
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->CoreVideo_GL_GetAttribute;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.PtrVidExtGL_GetAttribute) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.PtrVidExtGL_GetAttribute));
            }

            set
            {
                ((__Internal*)__Instance)->CoreVideo_GL_GetAttribute = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.PtrVidExtGL_SwapBuffers CoreVideoGL_SwapBuffers
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->CoreVideo_GL_SwapBuffers;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.PtrVidExtGL_SwapBuffers) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.PtrVidExtGL_SwapBuffers));
            }

            set
            {
                ((__Internal*)__Instance)->CoreVideo_GL_SwapBuffers = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.PtrVidExtGL_GetDefaultFramebuffer CoreVideoGL_GetDefaultFramebuffer
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->CoreVideo_GL_GetDefaultFramebuffer;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.PtrVidExtGL_GetDefaultFramebuffer) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.PtrVidExtGL_GetDefaultFramebuffer));
            }

            set
            {
                ((__Internal*)__Instance)->CoreVideo_GL_GetDefaultFramebuffer = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class ZilmarGFX_1_3_Cor64
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "ConfigurePlugin", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ConfigurePlugin(global::RunN64.External.GLide64.MUPEN_VID_EXT.__Internal vidExt);

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "CaptureScreen", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CaptureScreen(sbyte* Directory);

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "ChangeWindow", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ChangeWindow();

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "CloseDLL", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void CloseDLL();

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "DllAbout", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DllAbout(__IntPtr hParent);

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "DllConfig", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DllConfig(__IntPtr hParent);

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "DllTest", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DllTest(__IntPtr hParent);

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "DrawScreen", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void DrawScreen();

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "GetDllInfo", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void GetDllInfo(__IntPtr PluginInfo);

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "InitiateGFX", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int InitiateGFX(global::RunN64.External.GLide64.COR64GFX_INFO.__Internal Gfx_Info);

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "MoveScreen", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void MoveScreen(int xpos, int ypos);

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "ProcessDList", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ProcessDList();

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "ProcessRDPList", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ProcessRDPList();

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "RomClosed", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void RomClosed();

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "RomOpen", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void RomOpen();

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "ShowCFB", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ShowCFB();

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "UpdateScreen", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void UpdateScreen();

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "ViStatusChanged", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ViStatusChanged();

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "ViWidthChanged", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ViWidthChanged();

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "ReadScreen", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void ReadScreen(__IntPtr* dest, long* width, long* height);
        }

        public static void ConfigurePlugin(global::RunN64.External.GLide64.MUPEN_VID_EXT vidExt)
        {
            if (ReferenceEquals(vidExt, null))
                throw new global::System.ArgumentNullException("vidExt", "Cannot be null because it is passed by value.");
            var __arg0 = vidExt.__Instance;
            __Internal.ConfigurePlugin(*(global::RunN64.External.GLide64.MUPEN_VID_EXT.__Internal*) __arg0);
        }

        /// <summary>
        /// <para>****************************************************************</para>
        /// <para>Function: CaptureScreen</para>
        /// <para>Purpose:  This function dumps the current frame to a file</para>
        /// <para>input:    pointer to the directory to save the file to</para>
        /// <para>output:   none</para>
        /// <para>*****************************************************************</para>
        /// </summary>
        public static void CaptureScreen(sbyte* Directory)
        {
            __Internal.CaptureScreen(Directory);
        }

        /// <summary>
        /// <para>****************************************************************</para>
        /// <para>Function: ChangeWindow</para>
        /// <para>Purpose:  to change the window between fullscreen and window</para>
        /// <para>mode. If the window was in fullscreen this should</para>
        /// <para>change the screen to window mode and vice vesa.</para>
        /// <para>input:    none</para>
        /// <para>output:   none</para>
        /// <para>*****************************************************************</para>
        /// </summary>
        public static void ChangeWindow()
        {
            __Internal.ChangeWindow();
        }

        /// <summary>
        /// <para>****************************************************************</para>
        /// <para>Function: CloseDLL</para>
        /// <para>Purpose:  This function is called when the emulator is closing</para>
        /// <para>down allowing the dll to de-initialise.</para>
        /// <para>input:    none</para>
        /// <para>output:   none</para>
        /// <para>*****************************************************************</para>
        /// </summary>
        public static void CloseDLL()
        {
            __Internal.CloseDLL();
        }

        /// <summary>
        /// <para>****************************************************************</para>
        /// <para>Function: DllAbout</para>
        /// <para>Purpose:  This function is optional function that is provided</para>
        /// <para>to give further information about the DLL.</para>
        /// <para>input:    a handle to the window that calls this function</para>
        /// <para>output:   none</para>
        /// <para>*****************************************************************</para>
        /// </summary>
        public static void DllAbout(__IntPtr hParent)
        {
            __Internal.DllAbout(hParent);
        }

        /// <summary>
        /// <para>****************************************************************</para>
        /// <para>Function: DllConfig</para>
        /// <para>Purpose:  This function is optional function that is provided</para>
        /// <para>to allow the user to configure the dll</para>
        /// <para>input:    a handle to the window that calls this function</para>
        /// <para>output:   none</para>
        /// <para>*****************************************************************</para>
        /// </summary>
        public static void DllConfig(__IntPtr hParent)
        {
            __Internal.DllConfig(hParent);
        }

        /// <summary>
        /// <para>****************************************************************</para>
        /// <para>Function: DllTest</para>
        /// <para>Purpose:  This function is optional function that is provided</para>
        /// <para>to allow the user to test the dll</para>
        /// <para>input:    a handle to the window that calls this function</para>
        /// <para>output:   none</para>
        /// <para>*****************************************************************</para>
        /// </summary>
        public static void DllTest(__IntPtr hParent)
        {
            __Internal.DllTest(hParent);
        }

        /// <summary>
        /// <para>****************************************************************</para>
        /// <para>Function: DrawScreen</para>
        /// <para>Purpose:  This function is called when the emulator receives a</para>
        /// <para>WM_PAINT message. This allows the gfx to fit in when</para>
        /// <para>it is being used in the desktop.</para>
        /// <para>input:    none</para>
        /// <para>output:   none</para>
        /// <para>*****************************************************************</para>
        /// </summary>
        public static void DrawScreen()
        {
            __Internal.DrawScreen();
        }

        /// <summary>
        /// <para>****************************************************************</para>
        /// <para>Function: GetDllInfo</para>
        /// <para>Purpose:  This function allows the emulator to gather information</para>
        /// <para>about the dll by filling in the PluginInfo structure.</para>
        /// <para>input:    a pointer to a PLUGIN_INFO stucture that needs to be</para>
        /// <para>filled by the function. (see def above)</para>
        /// <para>output:   none</para>
        /// <para>*****************************************************************</para>
        /// </summary>
        public static void GetDllInfo(global::RunN64.External.GLide64.PLUGIN_INFO PluginInfo)
        {
            var __arg0 = PluginInfo is null ? __IntPtr.Zero : PluginInfo.__Instance;
            __Internal.GetDllInfo(__arg0);
        }

        /// <summary>
        /// <para>****************************************************************</para>
        /// <para>Function: InitiateGFX</para>
        /// <para>Purpose:  This function is called when the DLL is started to give</para>
        /// <para>information from the emulator that the n64 graphics</para>
        /// <para>uses. This is not called from the emulation thread.</para>
        /// <para>Input:    Gfx_Info is passed to this function which is defined</para>
        /// <para>above.</para>
        /// <para>Output:   TRUE on success</para>
        /// <para>FALSE on failure to initialise</para>
        /// </summary>
        /// <remarks>
        /// <para>* note on interrupts **:</para>
        /// <para>To generate an interrupt set the appropriate bit in MI_INTR_REG</para>
        /// <para>and then call the function CheckInterrupts to tell the emulator</para>
        /// <para>that there is a waiting interrupt.</para>
        /// <para>*****************************************************************</para>
        /// </remarks>
        public static int InitiateGFX(global::RunN64.External.GLide64.COR64GFX_INFO Gfx_Info)
        {
            if (ReferenceEquals(Gfx_Info, null))
                throw new global::System.ArgumentNullException("Gfx_Info", "Cannot be null because it is passed by value.");
            var __arg0 = Gfx_Info.__Instance;
            var __ret = __Internal.InitiateGFX(*(global::RunN64.External.GLide64.COR64GFX_INFO.__Internal*) __arg0);
            return __ret;
        }

        /// <summary>
        /// <para>****************************************************************</para>
        /// <para>Function: MoveScreen</para>
        /// <para>Purpose:  This function is called in response to the emulator</para>
        /// <para>receiving a WM_MOVE passing the xpos and ypos passed</para>
        /// <para>from that message.</para>
        /// <para>input:    xpos - the x-coordinate of the upper-left corner of the</para>
        /// <para>client area of the window.</para>
        /// <para>ypos - y-coordinate of the upper-left corner of the</para>
        /// <para>client area of the window.</para>
        /// <para>output:   none</para>
        /// <para>*****************************************************************</para>
        /// </summary>
        public static void MoveScreen(int xpos, int ypos)
        {
            __Internal.MoveScreen(xpos, ypos);
        }

        /// <summary>
        /// <para>****************************************************************</para>
        /// <para>Function: ProcessDList</para>
        /// <para>Purpose:  This function is called when there is a Dlist to be</para>
        /// <para>processed. (High level GFX list)</para>
        /// <para>input:    none</para>
        /// <para>output:   none</para>
        /// <para>*****************************************************************</para>
        /// </summary>
        public static void ProcessDList()
        {
            __Internal.ProcessDList();
        }

        /// <summary>
        /// <para>****************************************************************</para>
        /// <para>Function: ProcessRDPList</para>
        /// <para>Purpose:  This function is called when there is a Dlist to be</para>
        /// <para>processed. (Low level GFX list)</para>
        /// <para>input:    none</para>
        /// <para>output:   none</para>
        /// <para>*****************************************************************</para>
        /// </summary>
        public static void ProcessRDPList()
        {
            __Internal.ProcessRDPList();
        }

        /// <summary>
        /// <para>****************************************************************</para>
        /// <para>Function: RomClosed</para>
        /// <para>Purpose:  This function is called when a rom is closed.</para>
        /// <para>input:    none</para>
        /// <para>output:   none</para>
        /// <para>*****************************************************************</para>
        /// </summary>
        public static void RomClosed()
        {
            __Internal.RomClosed();
        }

        /// <summary>
        /// <para>****************************************************************</para>
        /// <para>Function: RomOpen</para>
        /// <para>Purpose:  This function is called when a rom is open. (from the</para>
        /// <para>emulation thread)</para>
        /// <para>input:    none</para>
        /// <para>output:   none</para>
        /// <para>*****************************************************************</para>
        /// </summary>
        public static void RomOpen()
        {
            __Internal.RomOpen();
        }

        /// <summary>
        /// <para>****************************************************************</para>
        /// <para>Function: ShowCFB</para>
        /// <para>Purpose:  Useally once Dlists are started being displayed, cfb is</para>
        /// <para>ignored. This function tells the dll to start displaying</para>
        /// <para>them again.</para>
        /// <para>input:    none</para>
        /// <para>output:   none</para>
        /// <para>*****************************************************************</para>
        /// </summary>
        public static void ShowCFB()
        {
            __Internal.ShowCFB();
        }

        /// <summary>
        /// <para>****************************************************************</para>
        /// <para>Function: UpdateScreen</para>
        /// <para>Purpose:  This function is called in response to a vsync of the</para>
        /// <para>screen were the VI bit in MI_INTR_REG has already been</para>
        /// <para>set</para>
        /// <para>input:    none</para>
        /// <para>output:   none</para>
        /// <para>*****************************************************************</para>
        /// </summary>
        public static void UpdateScreen()
        {
            __Internal.UpdateScreen();
        }

        /// <summary>
        /// <para>****************************************************************</para>
        /// <para>Function: ViStatusChanged</para>
        /// <para>Purpose:  This function is called to notify the dll that the</para>
        /// <para>ViStatus registers value has been changed.</para>
        /// <para>input:    none</para>
        /// <para>output:   none</para>
        /// <para>*****************************************************************</para>
        /// </summary>
        public static void ViStatusChanged()
        {
            __Internal.ViStatusChanged();
        }

        /// <summary>
        /// <para>****************************************************************</para>
        /// <para>Function: ViWidthChanged</para>
        /// <para>Purpose:  This function is called to notify the dll that the</para>
        /// <para>ViWidth registers value has been changed.</para>
        /// <para>input:    none</para>
        /// <para>output:   none</para>
        /// <para>*****************************************************************</para>
        /// </summary>
        public static void ViWidthChanged()
        {
            __Internal.ViWidthChanged();
        }

        /// <summary>
        /// <para>****************************************************************</para>
        /// <para>Function: ReadScreen</para>
        /// <para>Purpose:  Capture the current screen</para>
        /// <para>Input:    none</para>
        /// <para>Output:   dest - 24-bit RGB data (flipped horizontally)</para>
        /// <para>width - width of image</para>
        /// <para>height - height of image</para>
        /// <para>****************************************************************</para>
        /// </summary>
        public static void ReadScreen(__IntPtr* dest, ref long width, ref long height)
        {
            fixed (long* __width1 = &width)
            {
                var __arg1 = __width1;
                fixed (long* __height2 = &height)
                {
                    var __arg2 = __height2;
                    __Internal.ReadScreen(dest, __arg1, __arg2);
                }
            }
        }
    }

    public enum M64pType : uint
    {
        M64TYPE_INT = 1,
        M64TYPE_FLOAT = 2,
        M64TYPE_BOOL = 3,
        M64TYPE_STRING = 4
    }

    public enum M64pMsgLevel : uint
    {
        M64MSG_ERROR = 1,
        M64MSG_WARNING = 2,
        M64MSG_INFO = 3,
        M64MSG_STATUS = 4,
        M64MSG_VERBOSE = 5
    }

    public enum M64pError : uint
    {
        M64ERR_SUCCESS = 0,
        M64ERR_NOT_INIT = 1,
        M64ERR_ALREADY_INIT = 2,
        M64ERR_INCOMPATIBLE = 3,
        M64ERR_INPUT_ASSERT = 4,
        M64ERR_INPUT_INVALID = 5,
        M64ERR_INPUT_NOT_FOUND = 6,
        M64ERR_NO_MEMORY = 7,
        M64ERR_FILES = 8,
        M64ERR_INTERNAL = 9,
        M64ERR_INVALID_STATE = 10,
        M64ERR_PLUGIN_FAIL = 11,
        M64ERR_SYSTEM_FAIL = 12,
        M64ERR_UNSUPPORTED = 13,
        M64ERR_WRONG_TYPE = 14
    }

    [Flags]
    public enum M64pCoreCaps : uint
    {
        M64CAPS_DYNAREC = 1,
        M64CAPS_DEBUGGER = 2,
        M64CAPS_CORE_COMPARE = 4
    }

    public enum M64pPluginType : uint
    {
        M64PLUGIN_NULL = 0,
        M64PLUGIN_RSP = 1,
        M64PLUGIN_GFX = 2,
        M64PLUGIN_AUDIO = 3,
        M64PLUGIN_INPUT = 4,
        M64PLUGIN_CORE = 5
    }

    public enum M64pEmuState : uint
    {
        M64EMU_STOPPED = 1,
        M64EMU_RUNNING = 2,
        M64EMU_PAUSED = 3
    }

    public enum M64pVideoMode : uint
    {
        M64VIDEO_NONE = 1,
        M64VIDEO_WINDOWED = 2,
        M64VIDEO_FULLSCREEN = 3
    }

    public enum M64pVideoFlags : uint
    {
        M64VIDEOFLAG_SUPPORT_RESIZING = 1
    }

    public enum M64pCoreParam : uint
    {
        M64CORE_EMU_STATE = 1,
        M64CORE_VIDEO_MODE = 2,
        M64CORE_SAVESTATE_SLOT = 3,
        M64CORE_SPEED_FACTOR = 4,
        M64CORE_SPEED_LIMITER = 5,
        M64CORE_VIDEO_SIZE = 6,
        M64CORE_AUDIO_VOLUME = 7,
        M64CORE_AUDIO_MUTE = 8,
        M64CORE_INPUT_GAMESHARK = 9,
        M64CORE_STATE_LOADCOMPLETE = 10,
        M64CORE_STATE_SAVECOMPLETE = 11
    }

    public enum M64pCommand : uint
    {
        M64CMD_NOP = 0,
        M64CMD_ROM_OPEN = 1,
        M64CMD_ROM_CLOSE = 2,
        M64CMD_ROM_GET_HEADER = 3,
        M64CMD_ROM_GET_SETTINGS = 4,
        M64CMD_EXECUTE = 5,
        M64CMD_STOP = 6,
        M64CMD_PAUSE = 7,
        M64CMD_RESUME = 8,
        M64CMD_CORE_STATE_QUERY = 9,
        M64CMD_STATE_LOAD = 10,
        M64CMD_STATE_SAVE = 11,
        M64CMD_STATE_SET_SLOT = 12,
        M64CMD_SEND_SDL_KEYDOWN = 13,
        M64CMD_SEND_SDL_KEYUP = 14,
        M64CMD_SET_FRAME_CALLBACK = 15,
        M64CMD_TAKE_NEXT_SCREENSHOT = 16,
        M64CMD_CORE_STATE_SET = 17,
        M64CMD_READ_SCREEN = 18,
        M64CMD_RESET = 19,
        M64CMD_ADVANCE_FRAME = 20,
        M64CMD_SET_MEDIA_LOADER = 21,
        M64CMD_NETPLAY_INIT = 22,
        M64CMD_NETPLAY_CONTROL_PLAYER = 23,
        M64CMD_NETPLAY_GET_VERSION = 24,
        M64CMD_NETPLAY_CLOSE = 25
    }

    public enum M64pSystemType : uint
    {
        SYSTEM_NTSC = 0,
        SYSTEM_PAL = 1,
        SYSTEM_MPAL = 2
    }

    public enum M64pDbgState : uint
    {
        M64P_DBG_RUN_STATE = 1,
        M64P_DBG_PREVIOUS_PC = 2,
        M64P_DBG_NUM_BREAKPOINTS = 3,
        M64P_DBG_CPU_DYNACORE = 4,
        M64P_DBG_CPU_NEXT_INTERRUPT = 5
    }

    public enum M64pDbgRunstate : uint
    {
        M64P_DBG_RUNSTATE_PAUSED = 0,
        M64P_DBG_RUNSTATE_STEPPING = 1,
        M64P_DBG_RUNSTATE_RUNNING = 2
    }

    public enum M64pDbgMemInfo : uint
    {
        M64P_DBG_MEM_TYPE = 1,
        M64P_DBG_MEM_FLAGS = 2,
        M64P_DBG_MEM_HAS_RECOMPILED = 3,
        M64P_DBG_MEM_NUM_RECOMPILED = 4,
        M64P_DBG_RECOMP_OPCODE = 16,
        M64P_DBG_RECOMP_ARGS = 17,
        M64P_DBG_RECOMP_ADDR = 18
    }

    public enum M64pDbgMemType : uint
    {
        M64P_MEM_NOMEM = 0,
        M64P_MEM_NOTHING = 1,
        M64P_MEM_RDRAM = 2,
        M64P_MEM_RDRAMREG = 3,
        M64P_MEM_RSPMEM = 4,
        M64P_MEM_RSPREG = 5,
        M64P_MEM_RSP = 6,
        M64P_MEM_DP = 7,
        M64P_MEM_DPS = 8,
        M64P_MEM_VI = 9,
        M64P_MEM_AI = 10,
        M64P_MEM_PI = 11,
        M64P_MEM_RI = 12,
        M64P_MEM_SI = 13,
        M64P_MEM_FLASHRAMSTAT = 14,
        M64P_MEM_ROM = 15,
        M64P_MEM_PIF = 16,
        M64P_MEM_MI = 17,
        M64P_MEM_BREAKPOINT = 18
    }

    [Flags]
    public enum M64pDbgMemFlags : uint
    {
        M64P_MEM_FLAG_READABLE = 0x1,
        M64P_MEM_FLAG_WRITABLE = 0x2,
        M64P_MEM_FLAG_READABLE_EMUONLY = 0x4,
        M64P_MEM_FLAG_WRITABLE_EMUONLY = 0x8
    }

    public enum M64pDbgMemptrType : uint
    {
        M64P_DBG_PTR_RDRAM = 1,
        M64P_DBG_PTR_PI_REG = 2,
        M64P_DBG_PTR_SI_REG = 3,
        M64P_DBG_PTR_VI_REG = 4,
        M64P_DBG_PTR_RI_REG = 5,
        M64P_DBG_PTR_AI_REG = 6
    }

    public enum M64pDbgCpuData : uint
    {
        M64P_CPU_PC = 1,
        M64P_CPU_REG_REG = 2,
        M64P_CPU_REG_HI = 3,
        M64P_CPU_REG_LO = 4,
        M64P_CPU_REG_COP0 = 5,
        M64P_CPU_REG_COP1DOUBLE_PTR = 6,
        M64P_CPU_REG_COP1SIMPLE_PTR = 7,
        M64P_CPU_REG_COP1FGR_64 = 8,
        M64P_CPU_TLB = 9
    }

    public enum M64pDbgBkpCommand : uint
    {
        M64P_BKP_CMD_ADD_ADDR = 1,
        M64P_BKP_CMD_ADD_STRUCT = 2,
        M64P_BKP_CMD_REPLACE = 3,
        M64P_BKP_CMD_REMOVE_ADDR = 4,
        M64P_BKP_CMD_REMOVE_IDX = 5,
        M64P_BKP_CMD_ENABLE = 6,
        M64P_BKP_CMD_DISABLE = 7,
        M64P_BKP_CMD_CHECK = 8
    }

    [Flags]
    public enum M64pDbgBkpFlags : uint
    {
        M64P_BKP_FLAG_ENABLED = 0x1,
        M64P_BKP_FLAG_READ = 0x2,
        M64P_BKP_FLAG_WRITE = 0x4,
        M64P_BKP_FLAG_EXEC = 0x8,
        M64P_BKP_FLAG_LOG = 0x10
    }

    public enum M64pGLattr : uint
    {
        M64P_GL_DOUBLEBUFFER = 1,
        M64P_GL_BUFFER_SIZE = 2,
        M64P_GL_DEPTH_SIZE = 3,
        M64P_GL_RED_SIZE = 4,
        M64P_GL_GREEN_SIZE = 5,
        M64P_GL_BLUE_SIZE = 6,
        M64P_GL_ALPHA_SIZE = 7,
        M64P_GL_SWAP_CONTROL = 8,
        M64P_GL_MULTISAMPLEBUFFERS = 9,
        M64P_GL_MULTISAMPLESAMPLES = 10,
        M64P_GL_CONTEXT_MAJOR_VERSION = 11,
        M64P_GL_CONTEXT_MINOR_VERSION = 12,
        M64P_GL_CONTEXT_PROFILE_MASK = 13
    }

    public enum M64pGLContextType : uint
    {
        M64P_GL_CONTEXT_PROFILE_CORE = 0,
        M64P_GL_CONTEXT_PROFILE_COMPATIBILITY = 1,
        M64P_GL_CONTEXT_PROFILE_ES = 2
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void M64pFunction();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void M64pFrameCallback(uint FrameIndex);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void M64pInputCallback();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void M64pAudioCallback();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void M64pViCallback();

    public unsafe partial class M64pCheatCode : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal uint address;
            internal int value;

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "_ZN15m64p_cheat_codeC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.GLide64.M64pCheatCode> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.GLide64.M64pCheatCode>();

        protected bool __ownsNativeInstance;

        internal static M64pCheatCode __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new M64pCheatCode(native.ToPointer(), skipVTables);
        }

        internal static M64pCheatCode __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (M64pCheatCode)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static M64pCheatCode __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new M64pCheatCode(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private M64pCheatCode(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected M64pCheatCode(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public M64pCheatCode()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.GLide64.M64pCheatCode.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public M64pCheatCode(global::RunN64.External.GLide64.M64pCheatCode __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.GLide64.M64pCheatCode.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::RunN64.External.GLide64.M64pCheatCode.__Internal*) __Instance) = *((global::RunN64.External.GLide64.M64pCheatCode.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Address
        {
            get
            {
                return ((__Internal*)__Instance)->address;
            }

            set
            {
                ((__Internal*)__Instance)->address = value;
            }
        }

        public int Value
        {
            get
            {
                return ((__Internal*)__Instance)->value;
            }

            set
            {
                ((__Internal*)__Instance)->value = value;
            }
        }
    }

    public unsafe partial class M64pMediaLoader : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            internal __IntPtr cb_data;
            internal __IntPtr get_gb_cart_rom;
            internal __IntPtr get_gb_cart_ram;
            internal __IntPtr get_dd_rom;
            internal __IntPtr get_dd_disk;

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "_ZN17m64p_media_loaderC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.GLide64.M64pMediaLoader> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.GLide64.M64pMediaLoader>();

        protected bool __ownsNativeInstance;

        internal static M64pMediaLoader __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new M64pMediaLoader(native.ToPointer(), skipVTables);
        }

        internal static M64pMediaLoader __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (M64pMediaLoader)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static M64pMediaLoader __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new M64pMediaLoader(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private M64pMediaLoader(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected M64pMediaLoader(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public M64pMediaLoader()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.GLide64.M64pMediaLoader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public M64pMediaLoader(global::RunN64.External.GLide64.M64pMediaLoader __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.GLide64.M64pMediaLoader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::RunN64.External.GLide64.M64pMediaLoader.__Internal*) __Instance) = *((global::RunN64.External.GLide64.M64pMediaLoader.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr CbData
        {
            get
            {
                return ((__Internal*)__Instance)->cb_data;
            }

            set
            {
                ((__Internal*)__Instance)->cb_data = (__IntPtr) value;
            }
        }

        public global::RunN64.External.GLide64.Delegates.Func_sbytePtr___IntPtr_int GetGbCartRom
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_gb_cart_rom;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.Delegates.Func_sbytePtr___IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.Delegates.Func_sbytePtr___IntPtr_int));
            }

            set
            {
                ((__Internal*)__Instance)->get_gb_cart_rom = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.Delegates.Func_sbytePtr___IntPtr_int GetGbCartRam
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_gb_cart_ram;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.Delegates.Func_sbytePtr___IntPtr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.Delegates.Func_sbytePtr___IntPtr_int));
            }

            set
            {
                ((__Internal*)__Instance)->get_gb_cart_ram = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.Delegates.Func_sbytePtr___IntPtr GetDdRom
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_dd_rom;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.Delegates.Func_sbytePtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.Delegates.Func_sbytePtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->get_dd_rom = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.Delegates.Func_sbytePtr___IntPtr GetDdDisk
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_dd_disk;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.Delegates.Func_sbytePtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.Delegates.Func_sbytePtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->get_dd_disk = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class M64pRomHeader : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            internal byte init_PI_BSB_DOM1_LAT_REG;
            internal byte init_PI_BSB_DOM1_PGS_REG;
            internal byte init_PI_BSB_DOM1_PWD_REG;
            internal byte init_PI_BSB_DOM1_PGS_REG2;
            internal uint ClockRate;
            internal uint PC;
            internal uint Release;
            internal uint CRC1;
            internal uint CRC2;
            internal fixed uint Unknown[2];
            internal fixed byte Name[20];
            internal uint unknown;
            internal uint Manufacturer_ID;
            internal ushort Cartridge_ID;
            internal ushort Country_code;

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "_ZN15m64p_rom_headerC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.GLide64.M64pRomHeader> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.GLide64.M64pRomHeader>();

        protected bool __ownsNativeInstance;

        internal static M64pRomHeader __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new M64pRomHeader(native.ToPointer(), skipVTables);
        }

        internal static M64pRomHeader __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (M64pRomHeader)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static M64pRomHeader __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new M64pRomHeader(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private M64pRomHeader(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected M64pRomHeader(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public M64pRomHeader()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.GLide64.M64pRomHeader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public M64pRomHeader(global::RunN64.External.GLide64.M64pRomHeader __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.GLide64.M64pRomHeader.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::RunN64.External.GLide64.M64pRomHeader.__Internal*) __Instance) = *((global::RunN64.External.GLide64.M64pRomHeader.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte InitPI_BSB_DOM1LAT_REG
        {
            get
            {
                return ((__Internal*)__Instance)->init_PI_BSB_DOM1_LAT_REG;
            }

            set
            {
                ((__Internal*)__Instance)->init_PI_BSB_DOM1_LAT_REG = value;
            }
        }

        public byte InitPI_BSB_DOM1PGS_REG
        {
            get
            {
                return ((__Internal*)__Instance)->init_PI_BSB_DOM1_PGS_REG;
            }

            set
            {
                ((__Internal*)__Instance)->init_PI_BSB_DOM1_PGS_REG = value;
            }
        }

        public byte InitPI_BSB_DOM1PWD_REG
        {
            get
            {
                return ((__Internal*)__Instance)->init_PI_BSB_DOM1_PWD_REG;
            }

            set
            {
                ((__Internal*)__Instance)->init_PI_BSB_DOM1_PWD_REG = value;
            }
        }

        public byte InitPI_BSB_DOM1PGS_REG2
        {
            get
            {
                return ((__Internal*)__Instance)->init_PI_BSB_DOM1_PGS_REG2;
            }

            set
            {
                ((__Internal*)__Instance)->init_PI_BSB_DOM1_PGS_REG2 = value;
            }
        }

        public uint ClockRate
        {
            get
            {
                return ((__Internal*)__Instance)->ClockRate;
            }

            set
            {
                ((__Internal*)__Instance)->ClockRate = value;
            }
        }

        public uint PC
        {
            get
            {
                return ((__Internal*)__Instance)->PC;
            }

            set
            {
                ((__Internal*)__Instance)->PC = value;
            }
        }

        public uint Release
        {
            get
            {
                return ((__Internal*)__Instance)->Release;
            }

            set
            {
                ((__Internal*)__Instance)->Release = value;
            }
        }

        public uint CRC1
        {
            get
            {
                return ((__Internal*)__Instance)->CRC1;
            }

            set
            {
                ((__Internal*)__Instance)->CRC1 = value;
            }
        }

        public uint CRC2
        {
            get
            {
                return ((__Internal*)__Instance)->CRC2;
            }

            set
            {
                ((__Internal*)__Instance)->CRC2 = value;
            }
        }

        public uint[] Unknown
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->Unknown, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->Unknown[i] = value[i];
                }
            }
        }

        public byte[] Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->Name, 20);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 20; i++)
                        ((__Internal*)__Instance)->Name[i] = value[i];
                }
            }
        }

        public uint unknown
        {
            get
            {
                return ((__Internal*)__Instance)->unknown;
            }

            set
            {
                ((__Internal*)__Instance)->unknown = value;
            }
        }

        public uint ManufacturerID
        {
            get
            {
                return ((__Internal*)__Instance)->Manufacturer_ID;
            }

            set
            {
                ((__Internal*)__Instance)->Manufacturer_ID = value;
            }
        }

        public ushort CartridgeID
        {
            get
            {
                return ((__Internal*)__Instance)->Cartridge_ID;
            }

            set
            {
                ((__Internal*)__Instance)->Cartridge_ID = value;
            }
        }

        public ushort Country_code
        {
            get
            {
                return ((__Internal*)__Instance)->Country_code;
            }

            set
            {
                ((__Internal*)__Instance)->Country_code = value;
            }
        }
    }

    public unsafe partial class M64pRomSettings : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 296)]
        public partial struct __Internal
        {
            internal fixed sbyte goodname[256];
            internal fixed sbyte MD5[33];
            internal byte savetype;
            internal byte status;
            internal byte players;
            internal byte rumble;
            internal byte transferpak;
            internal byte mempak;
            internal byte biopak;

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "_ZN17m64p_rom_settingsC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.GLide64.M64pRomSettings> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.GLide64.M64pRomSettings>();

        protected bool __ownsNativeInstance;

        internal static M64pRomSettings __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new M64pRomSettings(native.ToPointer(), skipVTables);
        }

        internal static M64pRomSettings __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (M64pRomSettings)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static M64pRomSettings __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new M64pRomSettings(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private M64pRomSettings(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected M64pRomSettings(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public M64pRomSettings()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.GLide64.M64pRomSettings.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public M64pRomSettings(global::RunN64.External.GLide64.M64pRomSettings __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.GLide64.M64pRomSettings.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::RunN64.External.GLide64.M64pRomSettings.__Internal*) __Instance) = *((global::RunN64.External.GLide64.M64pRomSettings.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte[] Goodname
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->goodname, 256);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 256; i++)
                        ((__Internal*)__Instance)->goodname[i] = value[i];
                }
            }
        }

        public sbyte[] MD5
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->MD5, 33);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 33; i++)
                        ((__Internal*)__Instance)->MD5[i] = value[i];
                }
            }
        }

        public byte Savetype
        {
            get
            {
                return ((__Internal*)__Instance)->savetype;
            }

            set
            {
                ((__Internal*)__Instance)->savetype = value;
            }
        }

        public byte Status
        {
            get
            {
                return ((__Internal*)__Instance)->status;
            }

            set
            {
                ((__Internal*)__Instance)->status = value;
            }
        }

        public byte Players
        {
            get
            {
                return ((__Internal*)__Instance)->players;
            }

            set
            {
                ((__Internal*)__Instance)->players = value;
            }
        }

        public byte Rumble
        {
            get
            {
                return ((__Internal*)__Instance)->rumble;
            }

            set
            {
                ((__Internal*)__Instance)->rumble = value;
            }
        }

        public byte Transferpak
        {
            get
            {
                return ((__Internal*)__Instance)->transferpak;
            }

            set
            {
                ((__Internal*)__Instance)->transferpak = value;
            }
        }

        public byte Mempak
        {
            get
            {
                return ((__Internal*)__Instance)->mempak;
            }

            set
            {
                ((__Internal*)__Instance)->mempak = value;
            }
        }

        public byte Biopak
        {
            get
            {
                return ((__Internal*)__Instance)->biopak;
            }

            set
            {
                ((__Internal*)__Instance)->biopak = value;
            }
        }
    }

    public unsafe partial class M64pBreakpoint : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal uint address;
            internal uint endaddr;
            internal uint flags;

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "_ZN15m64p_breakpointC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.GLide64.M64pBreakpoint> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.GLide64.M64pBreakpoint>();

        protected bool __ownsNativeInstance;

        internal static M64pBreakpoint __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new M64pBreakpoint(native.ToPointer(), skipVTables);
        }

        internal static M64pBreakpoint __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (M64pBreakpoint)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static M64pBreakpoint __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new M64pBreakpoint(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private M64pBreakpoint(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected M64pBreakpoint(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public M64pBreakpoint()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.GLide64.M64pBreakpoint.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public M64pBreakpoint(global::RunN64.External.GLide64.M64pBreakpoint __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.GLide64.M64pBreakpoint.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::RunN64.External.GLide64.M64pBreakpoint.__Internal*) __Instance) = *((global::RunN64.External.GLide64.M64pBreakpoint.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Address
        {
            get
            {
                return ((__Internal*)__Instance)->address;
            }

            set
            {
                ((__Internal*)__Instance)->address = value;
            }
        }

        public uint Endaddr
        {
            get
            {
                return ((__Internal*)__Instance)->endaddr;
            }

            set
            {
                ((__Internal*)__Instance)->endaddr = value;
            }
        }

        public uint Flags
        {
            get
            {
                return ((__Internal*)__Instance)->flags;
            }

            set
            {
                ((__Internal*)__Instance)->flags = value;
            }
        }
    }

    public unsafe partial class M64p2dSize : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal uint uiWidth;
            internal uint uiHeight;

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "_ZN12m64p_2d_sizeC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.GLide64.M64p2dSize> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.GLide64.M64p2dSize>();

        protected bool __ownsNativeInstance;

        internal static M64p2dSize __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new M64p2dSize(native.ToPointer(), skipVTables);
        }

        internal static M64p2dSize __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (M64p2dSize)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static M64p2dSize __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new M64p2dSize(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private M64p2dSize(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected M64p2dSize(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public M64p2dSize()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.GLide64.M64p2dSize.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public M64p2dSize(global::RunN64.External.GLide64.M64p2dSize __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.GLide64.M64p2dSize.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::RunN64.External.GLide64.M64p2dSize.__Internal*) __Instance) = *((global::RunN64.External.GLide64.M64p2dSize.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint UiWidth
        {
            get
            {
                return ((__Internal*)__Instance)->uiWidth;
            }

            set
            {
                ((__Internal*)__Instance)->uiWidth = value;
            }
        }

        public uint UiHeight
        {
            get
            {
                return ((__Internal*)__Instance)->uiHeight;
            }

            set
            {
                ((__Internal*)__Instance)->uiHeight = value;
            }
        }
    }

    public unsafe partial class M64pVideoExtensionFunctions : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 120)]
        public partial struct __Internal
        {
            internal uint Functions;
            internal __IntPtr VidExtFuncInit;
            internal __IntPtr VidExtFuncQuit;
            internal __IntPtr VidExtFuncListModes;
            internal __IntPtr VidExtFuncListRates;
            internal __IntPtr VidExtFuncSetMode;
            internal __IntPtr VidExtFuncSetModeWithRate;
            internal __IntPtr VidExtFuncGLGetProc;
            internal __IntPtr VidExtFuncGLSetAttr;
            internal __IntPtr VidExtFuncGLGetAttr;
            internal __IntPtr VidExtFuncGLSwapBuf;
            internal __IntPtr VidExtFuncSetCaption;
            internal __IntPtr VidExtFuncToggleFS;
            internal __IntPtr VidExtFuncResizeWindow;
            internal __IntPtr VidExtFuncGLGetDefaultFramebuffer;

            [SuppressUnmanagedCodeSecurity, DllImport("cor64-GLideN64.so", EntryPoint = "_ZN30m64p_video_extension_functionsC2ERKS_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.GLide64.M64pVideoExtensionFunctions> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::RunN64.External.GLide64.M64pVideoExtensionFunctions>();

        protected bool __ownsNativeInstance;

        internal static M64pVideoExtensionFunctions __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new M64pVideoExtensionFunctions(native.ToPointer(), skipVTables);
        }

        internal static M64pVideoExtensionFunctions __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (M64pVideoExtensionFunctions)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static M64pVideoExtensionFunctions __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new M64pVideoExtensionFunctions(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private M64pVideoExtensionFunctions(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected M64pVideoExtensionFunctions(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public M64pVideoExtensionFunctions()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.GLide64.M64pVideoExtensionFunctions.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public M64pVideoExtensionFunctions(global::RunN64.External.GLide64.M64pVideoExtensionFunctions __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::RunN64.External.GLide64.M64pVideoExtensionFunctions.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::RunN64.External.GLide64.M64pVideoExtensionFunctions.__Internal*) __Instance) = *((global::RunN64.External.GLide64.M64pVideoExtensionFunctions.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Functions
        {
            get
            {
                return ((__Internal*)__Instance)->Functions;
            }

            set
            {
                ((__Internal*)__Instance)->Functions = value;
            }
        }

        public global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error VidExtFuncInit
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->VidExtFuncInit;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error));
            }

            set
            {
                ((__Internal*)__Instance)->VidExtFuncInit = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error VidExtFuncQuit
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->VidExtFuncQuit;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error));
            }

            set
            {
                ((__Internal*)__Instance)->VidExtFuncQuit = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error___IntPtr_intPtr VidExtFuncListModes
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->VidExtFuncListModes;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error___IntPtr_intPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error___IntPtr_intPtr));
            }

            set
            {
                ((__Internal*)__Instance)->VidExtFuncListModes = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error_RunN64_External_GLide64_m64p_2d_size___Internal_intPtr_intPtr VidExtFuncListRates
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->VidExtFuncListRates;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error_RunN64_External_GLide64_m64p_2d_size___Internal_intPtr_intPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error_RunN64_External_GLide64_m64p_2d_size___Internal_intPtr_intPtr));
            }

            set
            {
                ((__Internal*)__Instance)->VidExtFuncListRates = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error_int_int_int_int_int VidExtFuncSetMode
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->VidExtFuncSetMode;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error_int_int_int_int_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error_int_int_int_int_int));
            }

            set
            {
                ((__Internal*)__Instance)->VidExtFuncSetMode = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error_int_int_int_int_int_int VidExtFuncSetModeWithRate
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->VidExtFuncSetModeWithRate;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error_int_int_int_int_int_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error_int_int_int_int_int_int));
            }

            set
            {
                ((__Internal*)__Instance)->VidExtFuncSetModeWithRate = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_function_string8 VidExtFuncGLGetProc
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->VidExtFuncGLGetProc;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_function_string8) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_function_string8));
            }

            set
            {
                ((__Internal*)__Instance)->VidExtFuncGLGetProc = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error_RunN64_External_GLide64_m64p_GLattr_int VidExtFuncGLSetAttr
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->VidExtFuncGLSetAttr;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error_RunN64_External_GLide64_m64p_GLattr_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error_RunN64_External_GLide64_m64p_GLattr_int));
            }

            set
            {
                ((__Internal*)__Instance)->VidExtFuncGLSetAttr = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error_RunN64_External_GLide64_m64p_GLattr_intPtr VidExtFuncGLGetAttr
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->VidExtFuncGLGetAttr;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error_RunN64_External_GLide64_m64p_GLattr_intPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error_RunN64_External_GLide64_m64p_GLattr_intPtr));
            }

            set
            {
                ((__Internal*)__Instance)->VidExtFuncGLGetAttr = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error VidExtFuncGLSwapBuf
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->VidExtFuncGLSwapBuf;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error));
            }

            set
            {
                ((__Internal*)__Instance)->VidExtFuncGLSwapBuf = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error_string8 VidExtFuncSetCaption
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->VidExtFuncSetCaption;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error_string8) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error_string8));
            }

            set
            {
                ((__Internal*)__Instance)->VidExtFuncSetCaption = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error VidExtFuncToggleFS
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->VidExtFuncToggleFS;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error));
            }

            set
            {
                ((__Internal*)__Instance)->VidExtFuncToggleFS = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error_int_int VidExtFuncResizeWindow
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->VidExtFuncResizeWindow;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error_int_int) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.Delegates.Func_RunN64_External_GLide64_m64p_error_int_int));
            }

            set
            {
                ((__Internal*)__Instance)->VidExtFuncResizeWindow = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::RunN64.External.GLide64.Delegates.Func_uint VidExtFuncGLGetDefaultFramebuffer
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->VidExtFuncGLGetDefaultFramebuffer;
                return __ptr0 == IntPtr.Zero? null : (global::RunN64.External.GLide64.Delegates.Func_uint) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::RunN64.External.GLide64.Delegates.Func_uint));
            }

            set
            {
                ((__Internal*)__Instance)->VidExtFuncGLGetDefaultFramebuffer = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::RunN64.External.GLide64.M64pError PtrVidExtInit();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::RunN64.External.GLide64.M64pError PtrVidExtQuit();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::RunN64.External.GLide64.M64pError PtrVidExtListFullscreenModes(__IntPtr __0, int* __1);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::RunN64.External.GLide64.M64pError PtrVidExtListFullscreenRates(global::RunN64.External.GLide64.M64p2dSize.__Internal __0, int* __1, int* __2);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::RunN64.External.GLide64.M64pError PtrVidExtSetVideoMode(int __0, int __1, int __2, global::RunN64.External.GLide64.M64pVideoMode __3, global::RunN64.External.GLide64.M64pVideoFlags __4);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::RunN64.External.GLide64.M64pError PtrVidExtSetVideoModeWithRate(int __0, int __1, int __2, int __3, global::RunN64.External.GLide64.M64pVideoMode __4, global::RunN64.External.GLide64.M64pVideoFlags __5);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::RunN64.External.GLide64.M64pError PtrVidExtResizeWindow(int __0, int __1);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::RunN64.External.GLide64.M64pError PtrVidExtSetCaption([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string __0);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::RunN64.External.GLide64.M64pError PtrVidExtToggleFullScreen();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::RunN64.External.GLide64.M64pFunction PtrVidExtGL_GetProcAddress([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string __0);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::RunN64.External.GLide64.M64pError PtrVidExtGL_SetAttribute(global::RunN64.External.GLide64.M64pGLattr __0, int __1);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::RunN64.External.GLide64.M64pError PtrVidExtGL_GetAttribute(global::RunN64.External.GLide64.M64pGLattr __0, int* __1);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::RunN64.External.GLide64.M64pError PtrVidExtGL_SwapBuffers();

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate uint PtrVidExtGL_GetDefaultFramebuffer();

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate sbyte* Func_sbytePtr___IntPtr_int(__IntPtr cb_data, int controller_num);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate sbyte* Func_sbytePtr___IntPtr(__IntPtr cb_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate global::RunN64.External.GLide64.M64pError Func_RunN64_External_GLide64_m64p_error();

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate global::RunN64.External.GLide64.M64pError Func_RunN64_External_GLide64_m64p_error___IntPtr_intPtr(__IntPtr __0, int* __1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate global::RunN64.External.GLide64.M64pError Func_RunN64_External_GLide64_m64p_error_RunN64_External_GLide64_m64p_2d_size___Internal_intPtr_intPtr(global::RunN64.External.GLide64.M64p2dSize.__Internal __0, int* __1, int* __2);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate global::RunN64.External.GLide64.M64pError Func_RunN64_External_GLide64_m64p_error_int_int_int_int_int(int __0, int __1, int __2, int __3, int __4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate global::RunN64.External.GLide64.M64pError Func_RunN64_External_GLide64_m64p_error_int_int_int_int_int_int(int __0, int __1, int __2, int __3, int __4, int __5);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate global::RunN64.External.GLide64.M64pFunction Func_RunN64_External_GLide64_m64p_function_string8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string __0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate global::RunN64.External.GLide64.M64pError Func_RunN64_External_GLide64_m64p_error_RunN64_External_GLide64_m64p_GLattr_int(global::RunN64.External.GLide64.M64pGLattr __0, int __1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate global::RunN64.External.GLide64.M64pError Func_RunN64_External_GLide64_m64p_error_RunN64_External_GLide64_m64p_GLattr_intPtr(global::RunN64.External.GLide64.M64pGLattr __0, int* __1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate global::RunN64.External.GLide64.M64pError Func_RunN64_External_GLide64_m64p_error_string8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string __0);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate global::RunN64.External.GLide64.M64pError Func_RunN64_External_GLide64_m64p_error_int_int(int __0, int __1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate uint Func_uint();
    }
}
